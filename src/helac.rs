// Copyright 2018 Torsten Weber
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A specialized module for lhe files from HELAC-NLO
//!
//! This module contains types to read lhe files generated by the
//! various pieces of HELAC-NLO.
//! The additional information contained in these files is parsed into
//! specialized types.
//!
//! # Examples
//!
//! See the documentation for the different types for more information
//! about them and for actual, tested examples.
//!
//! ## Reading a file for the real-subtracted part
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::helac::LheFileRS;
//!
//! let lhe = LheFileRS::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // x1 of the 5th event
//! let x1 = lhe.events[4].extra.pdf.x1;
//! ```
//!
//! ## Reading a file for the I-operator part
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::helac::LheFileI;
//!
//! let lhe = LheFileI::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // matrix element weight of the 2nd event
//! let weight = lhe.events[2].extra.me.weight;
//! ```
//!
//! ## Reading a file for the KP-operator part
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::helac::LheFileKP;
//!
//! let lhe = LheFileKP::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // Lhapdf ids of all quarks used in beam one for this process.
//! let quark_ids = lhe.init.extra.pdf_sum.beam_1_quark_ids;
//! ```
//!
//! ## Reading a file for the LO+Virtual part
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::helac::LheFile1loop;
//!
//! let lhe = LheFile1loop::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // 1loop weight of the 1st event
//! let weight = lhe.events[0].extra.weight_1loop;
//! ```

use {PdgId, ReadLhe, WriteLhe};
use generic::LheFileGeneric;
use nom_util::{parse_f64, parse_i64, parse_i8, parse_u64, parse_u8};

use nom;
use std::io;
use std::str;

#[cfg(test)]
use quickcheck::Arbitrary;
#[cfg(test)]
use quickcheck::Gen;

/// A type to read files generated by HELAC-DIPOLES for the real-subtracted part
///
/// HELAC-DIPOLES doesn't exactly follow the lhe standard when
/// generating event files.
/// In particular, it doesn't store the cross section of the process
/// in the `init` section of the file, but the cross section divided by
/// the average weight of the events in the file.
/// Accordingly, the error given is the error on this ratio, not the
/// error on the cross section.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 4 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.00E+00 0.00E+00
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.00E+00 0.00E+00
///  5  1 1 2 0 0 3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.00E+00 0.00E+00
/// -5  1 1 2 0 0 2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 0 0 0
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// assert_eq!(init.beam_1_pdf_id, 13100);
/// assert_eq!(init.extra.pdf_sum.pdf_sum_pairs[0], (0,0));
///
/// let event = &lhe.events[0];
/// assert_eq!(event.weight, 1.25);
/// assert_eq!(event.particles[1].pdg_id, 21);
/// assert_eq!(event.extra.me.weight, 0.443);
/// ```
pub type LheFileRS = LheFileGeneric<Comment, Header, InitExtraRS, EventExtraRS>;

/// A type to read files generated by HELAC-DIPOLES for the I-operator
///
/// HELAC-DIPOLES doesn't exactly follow the lhe standard when
/// generating event files.
/// In particular, it doesn't store the cross section of the process
/// in the `init` section of the file, but the cross section divided by
/// the average weight of the events in the file.
/// Accordingly, the error given is the error on this ratio, not the
/// error on the cross section.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileI;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 2.50E+00 1.35E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// </init>
/// <event>
/// 8 81 -1.00E+00 1.73E+02 7.56E-03 1.07E-01
///  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.26E+01 9.26E+01 0.00E+00 0.00E+00 0.00E+00
///  21 -1 0 0 0 0  0.00E+00  0.00E+00 -8.06E+02 8.06E+02 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0  4.55E+01 -1.93E+01 -1.21E+01 5.09E+01 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.22E+01 -6.58E+01 -1.80E+02 2.13E+02 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0 -5.20E+01 -2.28E+00 -1.67E+02 1.75E+02 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.77E+01  4.27E+00  4.07E+00 1.86E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0  2.13E+00 -6.59E+01 -2.07E+02 2.17E+02 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0 -7.01E+01  1.49E+02 -1.49E+02 2.22E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.42E-02 1.24E-01 1.73E+02
/// ## me 4 3 -3.91E-05 4.52E-05 -1.65E-05 8.13E-07 0
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileI::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// assert_eq!(init.beam_1_pdf_id, 13100);
/// assert_eq!(init.extra.pdf_sum_pairs[0], (0,0));
///
/// let event = &lhe.events[0];
/// assert_eq!(event.weight, -1.);
/// assert_eq!(event.particles[4].pdg_id, 13);
/// assert_eq!(event.extra.me.weight, -3.91e-5);
/// ```
pub type LheFileI = LheFileGeneric<Comment, Header, PdfSum, EventExtraI>;

/// A type to read files generated by HELAC-DIPOLES for the KP-operator
///
/// HELAC-DIPOLES doesn't exactly follow the lhe standard when
/// generating event files.
/// In particular, it doesn't store the cross section of the process
/// in the `init` section of the file, but the cross section divided by
/// the average weight of the events in the file.
/// Accordingly, the error given is the error on this ratio, not the
/// error on the cross section.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileKP;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 8.00E-04 9.45E-07 1.00E+00 81
/// ## SUMPDF 1 1 1 1 0 -1 0 1
/// </init>
/// <event>
///   8 81 -1.00E+00 1.73E+02 7.56E-03 1.07E-01
///  -1 -1 0 0 0 0  0.00E+00  0.00E+00  9.81E+02 9.81E+02 0.00E+00 0.00E+00 0.00E+00
///   1 -1 0 0 0 0  0.00E+00  0.00E+00 -4.67E+01 4.67E+01 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0 -6.81E+01  7.84E+01  2.57E+02 2.78E+02 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.64E+00 -8.12E+00  7.25E+01 7.36E+01 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0  2.91E+01  2.33E+01  5.09E+01 6.31E+01 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.39E+01 -3.82E+01  4.55E+01 6.10E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0 -5.55E+01 -3.47E+01  4.73E+01 8.08E+01 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0  9.87E+01 -2.06E+01  4.60E+02 4.71E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.51E-01 7.18E-03 1.73E+02
/// ## me 4 3 -1.97E-07 5.74E-01 5.98E-01 2.60E-09 -3.42E-10 5.51E-08 -5.57E-09 0.00E+00 0.00E+00 -5.73E-08 5.92E-09 3.06E-09 -4.06E-10 6.93E-08 -7.06E-09 0.00E+00 0.00E+00 -6.75E-08 7.27E-09
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileKP::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// assert_eq!(init.beam_1_pdf_id, 13100);
/// assert_eq!(init.extra.beam_1_gluon_id, Some(0));
///
/// let event = &lhe.events[0];
/// assert_eq!(event.weight, -1.);
/// assert_eq!(event.particles[7].pdg_id, -5);
/// assert_eq!(event.extra.me.weight, -1.97e-7);
/// ```
pub type LheFileKP = LheFileGeneric<Comment, Header, PdfSumKP, EventExtraKP>;

/// A type to read files generated by HELAC-1LOOP for the LO+VIRTUAL part
///
/// Unlike for HELAC-DIPOLES, the cross section stored in the `ProcInfo`
/// part of the `init` section is actually the cross section itself.
/// The cross section normalized to the average weight is also included
/// and is stored in the `# NORM` line in the extra init information
/// and in the `Norm` struct, when read using this library.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFile1loop;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-1LOOP_v2.2
/// Type: LO+V
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 3.82E-02 2.87E-05 1.00E+00 81
/// ## NORM 100000 3.82E-02 2.91E-05
/// ## SUMPDF 2 1 -1 3 -3
/// </init>
/// <event>
/// 8 81 1.17E+00 1.73E+02 7.56E-03 1.07E-01
///   1 -1 0 0 102   0  0.00E+00  0.00E+00  4.84E+02 4.84E+02 0.00E+00 0.00E+00 9.00E+00
///  -1 -1 0 0   0 101  0.00E+00  0.00E+00 -3.84E+02 3.84E+02 0.00E+00 0.00E+00 9.00E+00
/// -11  1 1 2   0   0 -1.25E+02 -7.31E+01  1.21E+01 1.45E+02 0.00E+00 0.00E+00 9.00E+00
///  12  1 1 2   0   0  1.26E+01 -1.27E+01  2.55E+00 1.81E+01 0.00E+00 0.00E+00 9.00E+00
///  13  1 1 2   0   0  7.78E+01  9.57E+01 -1.46E+00 1.23E+02 0.00E+00 0.00E+00 9.00E+00
/// -14  1 1 2   0   0 -7.47E+00  8.68E+01  3.09E+01 9.24E+01 0.00E+00 0.00E+00 9.00E+00
///   5  1 1 2 102   0 -1.06E+02 -2.29E+02 -5.88E+01 2.59E+02 0.00E+00 0.00E+00 9.00E+00
///  -5  1 1 2   0 101  1.48E+02  1.32E+02  1.14E+02 2.29E+02 0.00E+00 0.00E+00 9.00E+00
/// ## pdf 7.45E-02 5.91E-02 1.73E+02
/// ## me 4 2 9.40E-09 4 3 1.62E-09 -6.47E-08 1.08E-08 -4.29E-10
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile1loop::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// assert_eq!(init.beam_1_pdf_id, 13100);
/// assert_eq!(init.extra.norm.alpha, 3.82e-2);
///
/// let event = &lhe.events[0];
/// assert_eq!(event.weight, 1.17);
/// assert_eq!(event.particles[2].pdg_id, -11);
/// assert_eq!(event.extra.me.weight_lo, 9.40e-9);
/// ```
pub type LheFile1loop = LheFileGeneric<Comment, Header, InitExtra1loop, EventExtra1loop>;

/// A mandatory comment
///
/// The information in the comment is stored as a String, with leading
/// and trailing whitespace removed.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::{LheFileRS, Comment};
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let Comment(ref comment) = lhe.comment;
/// assert_eq!(comment, &"File generated with HELAC-DIPOLES".to_string());
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct Comment(pub String);

impl ReadLhe for Comment {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], Comment> {
        map_res!(
            input,
            delimited!(tag!("<!--"), take_until!("-->"), tag!("-->")),
            |x| str::from_utf8(x).map(|x| Comment(x.trim().to_string()))
        )
    }
}

impl WriteLhe for Comment {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        let &Comment(ref s) = self;
        writeln!(writer, "<!--")?;
        writeln!(writer, "{}", s)?;
        writeln!(writer, "-->")
    }
}

#[cfg(test)]
impl Arbitrary for Comment {
    fn arbitrary<G: Gen>(gen: &mut G) -> Comment {
        let mut contents: String = Arbitrary::arbitrary(gen);
        while contents.contains("-->") {
            contents = Arbitrary::arbitrary(gen);
        }
        let contents = contents.trim().to_string();
        Comment(contents)
    }
}

/// A dummy header type
///
/// HELAC-NLO doesn't use a header in its lhe files, so this type does
/// nothing.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::{LheFileRS, Header};
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// assert_eq!(lhe.header, Header {});
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct Header {}
impl ReadLhe for Header {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], Header> {
        nom::IResult::Done(input, Header {})
    }
}

impl WriteLhe for Header {
    fn write_lhe<W: io::Write>(&self, _writer: &mut W) -> io::Result<()> {
        Ok(())
    }
}

#[cfg(test)]
impl Arbitrary for Header {
    fn arbitrary<G: Gen>(_gen: &mut G) -> Header {
        Header {}
    }
}

/// Information about the pdf summation used by RS, I and 1LOOP
///
/// This struct contains the information in the `SUMPDF` line
/// in the init section of lhe files generated for
///
/// * the real subtracted part
/// * the I-operator
/// * the LO+VIRTUAL part
///
/// The number of pairs is implicit as the length of `pdf_sum_pairs`.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 2 2 -2 4 -4
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// assert_eq!(init.extra.pdf_sum.pdf_sum_pairs.len(), 2);
/// assert_eq!(init.extra.pdf_sum.pdf_sum_pairs[0], (2,-2));
/// assert_eq!(init.extra.pdf_sum.pdf_sum_pairs[1], (4,-4));
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct PdfSum {
    /// Pairs of LHAPDF ids of the incoming particles that were summed
    /// over when generating the file.
    /// (The contents of `ipdfsumpair`).
    pub pdf_sum_pairs: Vec<(PdgId, PdgId)>,
}

impl ReadLhe for PdfSum {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], PdfSum> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("SUMPDF")) >> n: ws!(parse_u64)
                >> pdf_sum_pairs: count!(ws!(pair!(ws!(parse_i64), ws!(parse_i64))), n as usize)
                >> (PdfSum { pdf_sum_pairs })
        )
    }
}

impl WriteLhe for PdfSum {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        write!(writer, "# SUMPDF {}", self.pdf_sum_pairs.len())?;
        for pair in &self.pdf_sum_pairs {
            write!(writer, " {} {}", pair.0, pair.1)?;
        }
        writeln!(writer, "")
    }
}

#[cfg(test)]
impl Arbitrary for PdfSum {
    fn arbitrary<G: Gen>(gen: &mut G) -> PdfSum {
        PdfSum {
            pdf_sum_pairs: Arbitrary::arbitrary(gen),
        }
    }
}

/// Pdf information for events
///
/// The `# pdf` line in files generated for all pieces
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 4 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.00E+00 0.00E+00
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.00E+00 0.00E+00
///  5  1 1 2 0 0 3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.00E+00 0.00E+00
/// -5  1 1 2 0 0 2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 0 0 0
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let pdf = &event.extra.pdf;
/// assert_eq!(pdf.x1, 0.151);
/// assert_eq!(pdf.x2, 5.42e-3);
/// assert_eq!(pdf.scale, 173.);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct PdfInfo {
    /// The parton fraction of the first incoming parton
    pub x1: f64,
    /// The parton fraction of the second incoming parton
    pub x2: f64,
    /// The factorization scale
    pub scale: f64,
}

impl ReadLhe for PdfInfo {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], PdfInfo> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("pdf")) >> x1: ws!(parse_f64) >> x2: ws!(parse_f64)
                >> scale: ws!(parse_f64) >> (PdfInfo { x1, x2, scale })
        )
    }
}

impl WriteLhe for PdfInfo {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(writer, "# pdf {:e} {:e} {:e}", self.x1, self.x2, self.scale)
    }
}

#[cfg(test)]
impl Arbitrary for PdfInfo {
    fn arbitrary<G: Gen>(gen: &mut G) -> PdfInfo {
        PdfInfo {
            x1: Arbitrary::arbitrary(gen),
            x2: Arbitrary::arbitrary(gen),
            scale: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional initialization information used in the real-subtracted part
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let extra = &init.extra;
/// assert_eq!(extra.pdf_sum.pdf_sum_pairs[0], (0,0));
/// assert_eq!(extra.dip_map.dipole_type, 1);
/// assert_eq!(extra.jet_algo.dr, 0.4);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct InitExtraRS {
    /// Additional information about possible pdf summation (`# SUMPDF`)
    pub pdf_sum: PdfSum,
    /// Additional information about the subtraction (`# DIPMAP`)
    pub dip_map: DipMapInfo,
    /// Information about the jet algorithm used (`# JETALGO`)
    pub jet_algo: JetAlgoInfo,
}

impl ReadLhe for InitExtraRS {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], InitExtraRS> {
        do_parse!(
            input,
            ex:
                permutation!(
                    ws!(PdfSum::read_lhe),
                    ws!(DipMapInfo::read_lhe),
                    ws!(JetAlgoInfo::read_lhe)
                ) >> (InitExtraRS {
                pdf_sum: ex.0,
                dip_map: ex.1,
                jet_algo: ex.2,
            })
        )
    }
}

impl WriteLhe for InitExtraRS {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.pdf_sum.write_lhe(writer)?;
        self.dip_map.write_lhe(writer)?;
        self.jet_algo.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for InitExtraRS {
    fn arbitrary<G: Gen>(gen: &mut G) -> InitExtraRS {
        InitExtraRS {
            pdf_sum: Arbitrary::arbitrary(gen),
            dip_map: Arbitrary::arbitrary(gen),
            jet_algo: Arbitrary::arbitrary(gen),
        }
    }
}

/// Information about the jet algorithm used generating the real-subtracted part
///
/// # Examples
///
/// Without pt veto
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let jet_algo = &init.extra.jet_algo;
/// assert_eq!(jet_algo.n_bjets, 2);
/// assert_eq!(jet_algo.dr, 0.4);
/// assert_eq!(jet_algo.pt_veto, None);
/// ```
///
/// and with pt veto
///
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 T 5.00E+01
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let jet_algo = &init.extra.jet_algo;
/// assert_eq!(jet_algo.algorithm_id, -1);
/// assert_eq!(jet_algo.eta_max, 5.);
/// assert_eq!(jet_algo.pt_veto, Some(50.));
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct JetAlgoInfo {
    /// The HELAC id of the jet-algorithm
    pub algorithm_id: i8,
    /// The number of b-jets in the event
    pub n_bjets: u8,
    /// The maximum rapidity used to construct jets
    pub eta_max: f64,
    /// The R parameter of the jet algorithm
    pub dr: f64,
    /// A pt veto for the jet algorithm, if any
    pub pt_veto: Option<f64>,
}

impl ReadLhe for JetAlgoInfo {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], JetAlgoInfo> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("JETALGO")) >> algorithm_id: ws!(parse_i8)
                >> n_bjets: ws!(parse_u8) >> eta_max: ws!(parse_f64)
                >> dr: ws!(parse_f64)
                >> has_pt_veto: ws!(alt!(tag!("T") => {|_| true} | tag!("F") => {|_| false}))
                >> pt_veto: ws!(parse_f64) >> (JetAlgoInfo {
                algorithm_id,
                n_bjets,
                eta_max,
                dr,
                pt_veto: if has_pt_veto { Some(pt_veto) } else { None },
            })
        )
    }
}

impl WriteLhe for JetAlgoInfo {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "# JETALGO {} {} {:?} {:?} {} {:?}",
            self.algorithm_id,
            self.n_bjets,
            self.eta_max,
            self.dr,
            if self.pt_veto.is_some() { "T" } else { "F" },
            self.pt_veto.unwrap_or(0.)
        )
    }
}

#[cfg(test)]
impl Arbitrary for JetAlgoInfo {
    fn arbitrary<G: Gen>(gen: &mut G) -> JetAlgoInfo {
        JetAlgoInfo {
            algorithm_id: Arbitrary::arbitrary(gen),
            n_bjets: Arbitrary::arbitrary(gen),
            eta_max: Arbitrary::arbitrary(gen),
            dr: Arbitrary::arbitrary(gen),
            pt_veto: Arbitrary::arbitrary(gen),
        }
    }
}

/// Information about the dipoles used in the real-subtracted part
///
/// This object represents a mapping from the dipole id to the particles
/// that participate in the mapping to LO kinematics.
///
/// The map is implemented such that the dipole id (from the
/// `dipole_ids` field of [`MeInfoRS`]) is a one based index into the
/// `dipole_map`.
/// The entry at this index corresponds to the particle ids of the
/// particles `i` and `j` in the mapping.
/// These ids are used as one based indices into the particle vector
/// for the event.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 9 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
///  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.000E+00 0.00E+00
///  21 -1 0 0 0 0  0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.000E+00 0.00E+00
/// -11  1 1 2 0 0 -4.36E+01  1.25E+01  2.51E+02 2.55E+02 0.00E+00 0.000E+00 0.00E+00
///  12  1 1 2 0 0  2.64E+01 -1.40E+01  3.59E+02 3.60E+02 0.00E+00 0.000E+00 0.00E+00
///  13  1 1 2 0 0 -3.14E+01  2.86E+01  4.08E+01 5.89E+01 0.00E+00 0.000E+00 0.00E+00
/// -14  1 1 2 0 0 -8.24E+00  3.20E+01  2.36E+02 2.38E+02 0.00E+00 0.000E+00 0.00E+00
///   5  1 1 2 0 0  3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.000E+00 0.00E+00
///  -5  1 1 2 0 0  2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.000E+00 0.00E+00
///  21  1 1 2 0 0  2.17E-01 -1.19E+00  1.57E+00 1.99E+00 0.00E+00 0.000E+00 0.00E+00
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 7 9 5
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let dip_map = &init.extra.dip_map;
/// assert_eq!(dip_map.dipole_type, 1);
/// assert_eq!(dip_map.dipole_map.len(), 9);
/// assert_eq!(dip_map.dipole_map.len(), 9);
/// assert_eq!(dip_map.dipole_map[4], (2,8));
/// ```
///
/// The mapping for the fourth dipole in the event in this file works as
/// follows (see also [`EventExtraRS`] and [`MeInfoRS`]):
///
/// ```
/// # use lhef::ReadLhe;
/// # use lhef::helac::LheFileRS;
/// # let bytes = b"\
/// # <LesHouchesEvents version=\"1.0\">
/// # <!--
/// # File generated with HELAC-DIPOLES
/// # -->
/// # <init>
/// # 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// # 2.11E+00 3.22E-03 1.00E+00 81
/// # # SUMPDF 1 0 0
/// # # DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// # # JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// # </init>
/// # <event>
/// # 9 81 1.25E+00 1.73E+02 7.56E-03 1.07E-0
/// #  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.000E+00 0.00E+00
/// #  21 -1 0 0 0 0  0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.000E+00 0.00E+00
/// # -11  1 1 2 0 0 -4.36E+01  1.25E+01  2.51E+02 2.55E+02 0.00E+00 0.000E+00 0.00E+00
/// #  12  1 1 2 0 0  2.64E+01 -1.40E+01  3.59E+02 3.60E+02 0.00E+00 0.000E+00 0.00E+00
/// #  13  1 1 2 0 0 -3.14E+01  2.86E+01  4.08E+01 5.89E+01 0.00E+00 0.000E+00 0.00E+00
/// # -14  1 1 2 0 0 -8.24E+00  3.20E+01  2.36E+02 2.38E+02 0.00E+00 0.000E+00 0.00E+00
/// #   5  1 1 2 0 0  3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.000E+00 0.00E+00
/// #  -5  1 1 2 0 0  2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.000E+00 0.00E+00
/// #  21  1 1 2 0 0  2.17E-01 -1.19E+00  1.57E+00 1.99E+00 0.00E+00 0.000E+00 0.00E+00
/// # # pdf 1.51E-01 5.42E-03 1.73E+02
/// # # me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// # # jet 7 9 5
/// # </event>
/// # </LesHouchesEvents>";
/// # let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
/// # let init = &lhe.init;
/// # let dip_map = &init.extra.dip_map;
/// let event = &lhe.events[0];
/// let dipole_id = event.extra.me.dipole_ids[3];
/// // One based indexing!
/// let (i, j) = dip_map.dipole_map[dipole_id as usize - 1];
/// let particle_i = &event.particles[i as usize - 1];
/// let particle_j = &event.particles[j as usize - 1];
///
/// assert_eq!(particle_i.pdg_id, -5);
/// assert_eq!(particle_j.pdg_id, 21);
/// ```
///
/// [`EventExtraRS`]: helac/struct.EventExtraRS.html
/// [`MeInfoRS`]: helac/struct.MeInfoRS.html
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct DipMapInfo {
    /// HELAC id of the subtraction scheme used
    pub dipole_type: i8,
    /// A map from a dipole id (index in the vector) to the particles
    /// that are merged in the mapping to LO kinematics (the entries at
    /// that position).
    pub dipole_map: Vec<(i8, i8)>,
}

impl ReadLhe for DipMapInfo {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], DipMapInfo> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("DIPMAP")) >> dipole_type: ws!(parse_i8)
                >> ndipoles: ws!(parse_u8)
                >> dipole_map: count!(ws!(pair!(ws!(parse_i8), ws!(parse_i8))), ndipoles as usize)
                >> (DipMapInfo {
                    dipole_type,
                    dipole_map,
                })
        )
    }
}

impl WriteLhe for DipMapInfo {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        write!(
            writer,
            "# DIPMAP {} {}",
            self.dipole_type,
            self.dipole_map.len()
        )?;
        for dip in &self.dipole_map {
            write!(writer, " {} {}", dip.0, dip.1)?;
        }
        writeln!(writer, "")
    }
}

#[cfg(test)]
impl Arbitrary for DipMapInfo {
    fn arbitrary<G: Gen>(gen: &mut G) -> DipMapInfo {
        DipMapInfo {
            dipole_type: Arbitrary::arbitrary(gen),
            dipole_map: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional event information for the real-subtracted part
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 4 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.00E+00 0.0000
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.00E+00 0.0000
///  5  1 1 2 0 0 3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.00E+00 0.0000
/// -5  1 1 2 0 0 2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.00E+00 0.0000
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 7 9 5
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let extra = &event.extra;
/// assert_eq!(extra.pdf.x1, 0.151);
/// assert_eq!(extra.me.weight, 0.443);
/// assert_eq!(extra.jet.ibvjet1, 7);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct EventExtraRS {
    /// Additional pdf information (`# pdf`)
    pub pdf: PdfInfo,
    /// Additional matrix element and subtraction information (`# me`)
    pub me: MeInfoRS,
    /// Additional information about the jets in the event (`# jet`)
    pub jet: JetInfo,
}

impl ReadLhe for EventExtraRS {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], EventExtraRS> {
        do_parse!(
            input,
            ex:
                permutation!(
                    ws!(PdfInfo::read_lhe),
                    ws!(MeInfoRS::read_lhe),
                    ws!(JetInfo::read_lhe)
                ) >> (EventExtraRS {
                pdf: ex.0,
                me: ex.1,
                jet: ex.2,
            })
        )
    }
}

impl WriteLhe for EventExtraRS {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.pdf.write_lhe(writer)?;
        self.me.write_lhe(writer)?;
        self.jet.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for EventExtraRS {
    fn arbitrary<G: Gen>(gen: &mut G) -> EventExtraRS {
        EventExtraRS {
            pdf: Arbitrary::arbitrary(gen),
            me: Arbitrary::arbitrary(gen),
            jet: Arbitrary::arbitrary(gen),
        }
    }
}

/// Matrix element and subtraction information for the real-subtracted part
///
/// # Examples
///
/// With irun equal to one, i.e. with a running coupling and different
/// scales for each dipole
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 4 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.00E+00 0.0000
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.00E+00 0.0000
///  5  1 1 2 0 0 3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.00E+00 0.0000
/// -5  1 1 2 0 0 2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.00E+00 0.0000
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 7 9 5
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let me = &event.extra.me;
/// assert_eq!(me.weight, 0.443);
/// assert_eq!(me.scale, 173.);
/// assert_eq!(me.dipole_weights[2], 3.17e-2);
/// assert_eq!(me.dipole_mu_rs, Some(vec![173.; 4]));
/// ```
///
/// or with irun equal to zero and the same scale for everything
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 4 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.00E+00 0.0000
/// 21 -1 0 0 0 0 0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.00E+00 0.0000
///  5  1 1 2 0 0 3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.00E+00 0.0000
/// -5  1 1 2 0 0 2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.00E+00 0.0000
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 0 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01
/// ## jet 7 9 5
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let me = &event.extra.me;
/// assert_eq!(me.weight, 0.443);
/// assert_eq!(me.scale, 173.);
/// assert_eq!(me.dipole_weights[2], 3.17e-2);
/// assert_eq!(me.dipole_mu_rs, None);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct MeInfoRS {
    /// Total weight of the event
    pub weight: f64,
    /// Electroweak coupling power
    pub max_ew: u8,
    /// Strong coupling power
    pub max_qcd: u8,
    /// The weight of just the real part
    pub real_weight: f64,
    /// The renormalization scale of the real part or the whole event,
    /// depending on `irun`.
    pub scale: f64,
    /// The ids of the dipoles present in the event.
    /// These correspond to entries in the [`DipMapInfo`] struct.
    ///
    /// [`DipMapInfo`]: helac/struct.DipMapInfo.html
    pub dipole_ids: Vec<i8>,
    /// The weights of each individual dipole.
    pub dipole_weights: Vec<f64>,
    /// The renormalization scales of each dipole, if present.
    pub dipole_mu_rs: Option<Vec<f64>>,
}

impl ReadLhe for MeInfoRS {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], MeInfoRS> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("me")) >> weight: ws!(parse_f64) >> max_ew: ws!(parse_u8)
                >> max_qcd: ws!(parse_u8) >> real_weight: ws!(parse_f64)
                >> scale: ws!(parse_f64) >> irun: ws!(parse_u8)
                >> num_dipoles: ws!(parse_u8)
                >> dipole_ids: count!(ws!(parse_i8), num_dipoles as usize)
                >> dipole_weights: count!(ws!(parse_f64), num_dipoles as usize)
                >> dipole_mu_rs:
                    count!(
                        ws!(parse_f64),
                        (if irun > 0 { num_dipoles } else { 0 }) as usize
                    ) >> (MeInfoRS {
                weight,
                max_ew,
                max_qcd,
                real_weight,
                scale,
                dipole_ids,
                dipole_weights,
                dipole_mu_rs: if irun > 0 { Some(dipole_mu_rs) } else { None },
            })
        )
    }
}

impl WriteLhe for MeInfoRS {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        write!(
            writer,
            "# me {:e} {} {} {:e} {:e} {} {}",
            self.weight,
            self.max_ew,
            self.max_qcd,
            self.real_weight,
            self.scale,
            if self.dipole_mu_rs.is_some() { 1 } else { 0 },
            self.dipole_ids.len(),
        )?;
        for id in &self.dipole_ids {
            write!(writer, " {}", id)?;
        }
        for weight in &self.dipole_weights {
            write!(writer, " {}", weight)?;
        }
        if let Some(ref mu_rs) = self.dipole_mu_rs {
            for mu_r in mu_rs {
                write!(writer, " {}", mu_r)?;
            }
        }
        writeln!(writer, "")
    }
}

#[cfg(test)]
impl Arbitrary for MeInfoRS {
    fn arbitrary<G: Gen>(gen: &mut G) -> MeInfoRS {
        let dip: Vec<(i8, f64, f64)> = Arbitrary::arbitrary(gen);
        let mut dipole_ids = Vec::new();
        let mut dipole_weights = Vec::new();
        let irun: bool = Arbitrary::arbitrary(gen);
        let mut dipole_mu_rs = if irun { Some(Vec::new()) } else { None };
        for (i, w, m) in dip {
            dipole_ids.push(i);
            dipole_weights.push(w);
            dipole_mu_rs.as_mut().map(|v| v.push(m));
        }
        MeInfoRS {
            weight: Arbitrary::arbitrary(gen),
            max_ew: Arbitrary::arbitrary(gen),
            max_qcd: Arbitrary::arbitrary(gen),
            real_weight: Arbitrary::arbitrary(gen),
            scale: Arbitrary::arbitrary(gen),
            dipole_ids,
            dipole_weights,
            dipole_mu_rs,
        }
    }
}

/// Information about reconstructed jets in the real event
///
/// This structure contains information of which two partons where
/// merged into a jet and what flavour the final jet has.
///
/// The fields `ibvjet1` and `ibvjet2` contain a one based index
/// into the particles vector.
/// This means that the two particles pointed to have been combined into
/// a jet with flavour `ibvflreco`.
/// If the `ibvjet` variables and `ibvflreco` are less than or equal to
/// zero, this means that there is no reconstructed jet in the event.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileRS;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6.50E+03 6.50E+03 0 0 13100 13100 3 1
/// 2.11E+00 3.22E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// ## DIPMAP 1 9 1 7 1 8 1 9 2 7 2 8 2 9 7 8 7 9 8 9
/// ## JETALGO -1 2 5.00E+00 4.00E-01 F 5.00E+01
/// </init>
/// <event>
/// 9 81 1.25E+00 1.73E+02 7.56E-03 1.07E-01
///  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.85E+02 9.85E+02 0.00E+00 0.000E+00 0.00E+00
///  21 -1 0 0 0 0  0.00E+00  0.00E+00 -3.52E+01 3.52E+01 0.00E+00 0.000E+00 0.00E+00
/// -11  1 1 2 0 0 -4.36E+01  1.25E+01  2.51E+02 2.55E+02 0.00E+00 0.000E+00 0.00E+00
///  12  1 1 2 0 0  2.64E+01 -1.40E+01  3.59E+02 3.60E+02 0.00E+00 0.000E+00 0.00E+00
///  13  1 1 2 0 0 -3.14E+01  2.86E+01  4.08E+01 5.89E+01 0.00E+00 0.000E+00 0.00E+00
/// -14  1 1 2 0 0 -8.24E+00  3.20E+01  2.36E+02 2.38E+02 0.00E+00 0.000E+00 0.00E+00
///   5  1 1 2 0 0  3.66E+01 -2.12E+01  4.12E+01 5.91E+01 0.00E+00 0.000E+00 0.00E+00
///  -5  1 1 2 0 0  2.00E+01 -3.66E+01  1.95E+01 4.60E+01 0.00E+00 0.000E+00 0.00E+00
///  21  1 1 2 0 0  2.17E-01 -1.19E+00  1.57E+00 1.99E+00 0.00E+00 0.000E+00 0.00E+00
/// ## pdf 1.51E-01 5.42E-03 1.73E+02
/// ## me 4.43E-01 4 3 9.70E-01 1.73E+02 1 4 3 6 8 9 5.47E-02 1.34E-01 3.17E-02 3.05E-01 1.73E+02 1.73E+02 1.73E+02 1.73E+02
/// ## jet 7 9 5
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileRS::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let jet = &event.extra.jet;
/// assert_eq!(jet.ibvjet1, 7);
/// assert_eq!(jet.ibvjet2, 9);
/// assert_eq!(jet.ibvflreco, 5);
///
/// // Accessing the merged particles (1 based indexing!)
/// let particle_1 = &event.particles[jet.ibvjet1 as usize - 1];
/// let particle_2 = &event.particles[jet.ibvjet2 as usize - 1];
/// assert_eq!(particle_1.pdg_id, 5);
/// assert_eq!(particle_2.pdg_id, 21);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct JetInfo {
    /// Index of the first particle merged into a jet
    pub ibvjet1: i8,
    /// Index of the second particle merged into a jet
    pub ibvjet2: i8,
    /// Flavour of the reconstructed jet
    pub ibvflreco: i8,
}

impl ReadLhe for JetInfo {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], JetInfo> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("jet")) >> ibvjet1: ws!(parse_i8) >> ibvjet2: ws!(parse_i8)
                >> ibvflreco: ws!(parse_i8) >> (JetInfo {
                ibvjet1: ibvjet1,
                ibvjet2: ibvjet2,
                ibvflreco: ibvflreco,
            })
        )
    }
}

impl WriteLhe for JetInfo {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "# jet {} {} {}",
            self.ibvjet1, self.ibvjet2, self.ibvflreco,
        )
    }
}

#[cfg(test)]
impl Arbitrary for JetInfo {
    fn arbitrary<G: Gen>(gen: &mut G) -> JetInfo {
        JetInfo {
            ibvjet1: Arbitrary::arbitrary(gen),
            ibvjet2: Arbitrary::arbitrary(gen),
            ibvflreco: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional event information for the I-operator
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileI;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 2.50E+00 1.35E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// </init>
/// <event>
/// 8 81 -1.00E+00 1.73E+02 7.56E-03 1.07E-01
///  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.26E+01 9.26E+01 0.00E+00 0.00E+00 0.00E+00
///  21 -1 0 0 0 0  0.00E+00  0.00E+00 -8.06E+02 8.06E+02 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0  4.55E+01 -1.93E+01 -1.21E+01 5.09E+01 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.22E+01 -6.58E+01 -1.80E+02 2.13E+02 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0 -5.20E+01 -2.28E+00 -1.67E+02 1.75E+02 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.77E+01  4.27E+00  4.07E+00 1.86E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0  2.13E+00 -6.59E+01 -2.07E+02 2.17E+02 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0 -7.01E+01  1.49E+02 -1.49E+02 2.22E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.42E-02 1.24E-01 1.73E+02
/// ## me 4 3 -3.91E-05 4.52E-05 -1.65E-05 8.13E-07 0
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileI::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let extra = &event.extra;
/// assert_eq!(extra.pdf.x1, 1.42e-2);
/// assert_eq!(extra.me.weight, -3.91e-5);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct EventExtraI {
    /// Additional pdf information (`# pdf`)
    pub pdf: PdfInfo,
    /// Additional matrix element information (`# me`)
    pub me: MeInfoI,
}

impl ReadLhe for EventExtraI {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], EventExtraI> {
        do_parse!(
            input,
            ex: permutation!(ws!(PdfInfo::read_lhe), ws!(MeInfoI::read_lhe)) >> (EventExtraI {
                pdf: ex.0,
                me: ex.1,
            })
        )
    }
}

impl WriteLhe for EventExtraI {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.pdf.write_lhe(writer)?;
        self.me.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for EventExtraI {
    fn arbitrary<G: Gen>(gen: &mut G) -> EventExtraI {
        EventExtraI {
            pdf: Arbitrary::arbitrary(gen),
            me: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional matrix element level information for the I-operator
///
/// See the example for how the coeffients stored in this struct are
/// related to the weight.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileI;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 2.50E+00 1.35E-03 1.00E+00 81
/// ## SUMPDF 1 0 0
/// </init>
/// <event>
/// 8 81 -1.00E+00 1.732E+02 7.56E-03 1.07E-01
///  21 -1 0 0 0 0  0.00E+00  0.00E+00  9.26E+01 9.26E+01 0.00E+00 0.00E+00 0.00E+00
///  21 -1 0 0 0 0  0.00E+00  0.00E+00 -8.06E+02 8.06E+02 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0  4.55E+01 -1.93E+01 -1.21E+01 5.09E+01 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.22E+01 -6.58E+01 -1.80E+02 2.13E+02 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0 -5.20E+01 -2.28E+00 -1.67E+02 1.75E+02 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.77E+01  4.27E+00  4.07E+00 1.86E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0  2.13E+00 -6.59E+01 -2.07E+02 2.17E+02 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0 -7.01E+01  1.49E+02 -1.49E+02 2.22E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.42E-02 1.24E-01 1.73E+02
/// ## me  4  3 -3.910389934639022E-05  4.522266472328172E-05 -1.656815601466640E-05  8.136832461356407E-07  0
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileI::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let me = &event.extra.me;
/// assert_eq!(me.weight, -3.910389934639022E-05);
/// assert_eq!(me.coeff_a, 4.522266472328172E-05);
/// assert_eq!(me.coeff_b, -1.656815601466640E-05);
/// assert_eq!(me.coeff_c, 8.136832461356407E-07);
///
/// // The weight can be computed from the coefficients:
/// let log = (event.scale.powi(2)).ln();
/// let weight = me.coeff_a + me.coeff_b * log + me.coeff_c * log.powi(2);
/// assert!((me.weight - weight)/me.weight < 1e-12);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct MeInfoI {
    /// Electroweak coupling power
    pub max_ew: u8,
    /// Strong coupling power
    pub max_qcd: u8,
    /// Weight of the event
    pub weight: f64,
    /// The constant part of the matrix element
    pub coeff_a: f64,
    /// The coefficient of the `log(mu_r^2)` part of the matrix element
    pub coeff_b: f64,
    /// The coefficient of the `log(mu_r^2)^2` part of the matrix element
    pub coeff_c: f64,
    /// Which parts of the matrix element are included in the weight.
    /// If this is zero, then all pieces are included.
    pub log_term: i8,
}

impl ReadLhe for MeInfoI {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], MeInfoI> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("me")) >> max_ew: ws!(parse_u8) >> max_qcd: ws!(parse_u8)
                >> weight: ws!(parse_f64) >> coeff_a: ws!(parse_f64)
                >> coeff_b: ws!(parse_f64) >> coeff_c: ws!(parse_f64)
                >> log_term: ws!(parse_i8) >> (MeInfoI {
                max_ew,
                max_qcd,
                weight,
                coeff_a,
                coeff_b,
                coeff_c,
                log_term,
            })
        )
    }
}

impl WriteLhe for MeInfoI {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "# me {} {} {:e} {:e} {:e} {:e} {}",
            self.max_ew,
            self.max_qcd,
            self.weight,
            self.coeff_a,
            self.coeff_b,
            self.coeff_c,
            self.log_term
        )
    }
}

#[cfg(test)]
impl Arbitrary for MeInfoI {
    fn arbitrary<G: Gen>(gen: &mut G) -> MeInfoI {
        MeInfoI {
            max_ew: Arbitrary::arbitrary(gen),
            max_qcd: Arbitrary::arbitrary(gen),
            weight: Arbitrary::arbitrary(gen),
            coeff_a: Arbitrary::arbitrary(gen),
            coeff_b: Arbitrary::arbitrary(gen),
            coeff_c: Arbitrary::arbitrary(gen),
            log_term: Arbitrary::arbitrary(gen),
        }
    }
}

/// Information about the pdfs in the process for the KP-operator
///
/// This struct contains the lhapdf ids of all partons that can appear
/// in the initial state for this process.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileKP;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 8.00E-04 9.45E-07 1.00E+00 81
/// ## SUMPDF 1 1 0 1 0 -1 0 1
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileKP::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let pdf_sum = &init.extra;
/// assert_eq!(pdf_sum.beam_1_gluon_id, Some(0));
/// assert_eq!(pdf_sum.beam_2_gluon_id, None);
/// assert_eq!(pdf_sum.beam_1_quark_ids, vec![-1]);
/// assert_eq!(pdf_sum.beam_2_quark_ids, vec![1]);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct PdfSumKP {
    /// The lhapdf id of the gluon pdf for beam 1, if present
    pub beam_1_gluon_id: Option<PdgId>,
    /// The lhapdf id of the gluon pdf for beam 2, if present
    pub beam_2_gluon_id: Option<PdgId>,
    /// The lhapdf ids of all quarks in beam 1
    pub beam_1_quark_ids: Vec<PdgId>,
    /// The lhapdf ids of all quarks in beam 2
    pub beam_2_quark_ids: Vec<PdgId>,
}

impl ReadLhe for PdfSumKP {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], PdfSumKP> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("SUMPDF")) >> n_pdf_g_1: ws!(parse_u64)
                >> n_pdf_q_1: ws!(parse_u64) >> n_pdf_g_2: ws!(parse_u64)
                >> n_pdf_q_2: ws!(parse_u64) >> beam_1_gluon_id: ws!(parse_i64)
                >> beam_1_quark_ids: count!(ws!(parse_i64), n_pdf_q_1 as usize)
                >> beam_2_gluon_id: ws!(parse_i64)
                >> beam_2_quark_ids: count!(ws!(parse_i64), n_pdf_q_2 as usize)
                >> (PdfSumKP {
                    beam_1_gluon_id: if n_pdf_g_1 != 0 {
                        Some(beam_1_gluon_id)
                    } else {
                        None
                    },
                    beam_2_gluon_id: if n_pdf_g_2 != 0 {
                        Some(beam_2_gluon_id)
                    } else {
                        None
                    },
                    beam_1_quark_ids,
                    beam_2_quark_ids,
                })
        )
    }
}

impl WriteLhe for PdfSumKP {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        write!(
            writer,
            "# SUMPDF {} {} {} {}",
            if self.beam_1_gluon_id.is_some() { 1 } else { 0 },
            self.beam_1_quark_ids.len(),
            if self.beam_2_gluon_id.is_some() { 1 } else { 0 },
            self.beam_2_quark_ids.len(),
        )?;
        write!(writer, " {}", self.beam_1_gluon_id.unwrap_or(0))?;
        for id in &self.beam_1_quark_ids {
            write!(writer, " {}", id)?;
        }
        write!(writer, " {}", self.beam_2_gluon_id.unwrap_or(0))?;
        for id in &self.beam_2_quark_ids {
            write!(writer, " {}", id)?;
        }
        writeln!(writer, "")
    }
}

#[cfg(test)]
impl Arbitrary for PdfSumKP {
    fn arbitrary<G: Gen>(gen: &mut G) -> PdfSumKP {
        PdfSumKP {
            beam_1_gluon_id: Arbitrary::arbitrary(gen),
            beam_2_gluon_id: Arbitrary::arbitrary(gen),
            beam_1_quark_ids: Arbitrary::arbitrary(gen),
            beam_2_quark_ids: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional event information for the KP-operator
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileKP;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 8.00E-04 9.45E-07 1.00E+00 81
/// ## SUMPDF 1 1 1 1 0 -1 0 1
/// </init>
/// <event>
///   8 81 -1.00E+00 1.73E+02 7.56E-03 1.07E-01
///  -1 -1 0 0 0 0  0.00E+00  0.00E+00  9.81E+02 9.81E+02 0.00E+00 0.00E+00 0.00E+00
///   1 -1 0 0 0 0  0.00E+00  0.00E+00 -4.67E+01 4.67E+01 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0 -6.81E+01  7.84E+01  2.57E+02 2.78E+02 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.64E+00 -8.12E+00  7.25E+01 7.36E+01 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0  2.91E+01  2.33E+01  5.09E+01 6.31E+01 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.39E+01 -3.82E+01  4.55E+01 6.10E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0 -5.55E+01 -3.47E+01  4.73E+01 8.08E+01 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0  9.87E+01 -2.06E+01  4.60E+02 4.71E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.51E-01 7.18E-03 1.73E+02
/// ## me 4 3 -1.97E-07 5.74E-01 5.98E-01 2.60E-09 -3.42E-10 5.51E-08 -5.57E-09 0.00E+00 0.00E+00 -5.73E-08 5.92E-09 3.06E-09 -4.06E-10 6.93E-08 -7.06E-09 0.00E+00 0.00E+00 -6.75E-08 7.27E-09
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileKP::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let extra = &event.extra;
/// assert_eq!(extra.pdf.x1, 0.151);
/// assert_eq!(extra.me.weight, -1.97e-7);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct EventExtraKP {
    /// Additional pdf information (`# pdf`)
    pub pdf: PdfInfo,
    /// Additional matrix element information (`# me`)
    pub me: MeInfoKP,
}

impl ReadLhe for EventExtraKP {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], EventExtraKP> {
        do_parse!(
            input,
            ex: permutation!(ws!(PdfInfo::read_lhe), ws!(MeInfoKP::read_lhe)) >> (EventExtraKP {
                pdf: ex.0,
                me: ex.1,
            })
        )
    }
}

impl WriteLhe for EventExtraKP {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.pdf.write_lhe(writer)?;
        self.me.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for EventExtraKP {
    fn arbitrary<G: Gen>(gen: &mut G) -> EventExtraKP {
        EventExtraKP {
            pdf: Arbitrary::arbitrary(gen),
            me: Arbitrary::arbitrary(gen),
        }
    }
}

/// Matrix element information for the KP-operator
///
/// The weights stored in this struct can be used to compute the overall
/// weight of the event. This procedure involves the values of the pdfs
/// at both the `x`s stored in the `PdfInfo` struct as well as at e.g.
/// `x1/x1_prime`.
/// Therefore this procedure is to involved to be put into an example
/// here.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFileKP;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-DIPOLES
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 8.00E-04 9.45E-07 1.00E+00 81
/// ## SUMPDF 1 1 1 1 0 -1 0 1
/// </init>
/// <event>
///   8 81 -1.00E+00 1.73E+02 7.56E-03 1.07E-01
///  -1 -1 0 0 0 0  0.00E+00  0.00E+00  9.81E+02 9.81E+02 0.00E+00 0.00E+00 0.00E+00
///   1 -1 0 0 0 0  0.00E+00  0.00E+00 -4.67E+01 4.67E+01 0.00E+00 0.00E+00 0.00E+00
/// -11  1 1 2 0 0 -6.81E+01  7.84E+01  2.57E+02 2.78E+02 0.00E+00 0.00E+00 0.00E+00
///  12  1 1 2 0 0  9.64E+00 -8.12E+00  7.25E+01 7.36E+01 0.00E+00 0.00E+00 0.00E+00
///  13  1 1 2 0 0  2.91E+01  2.33E+01  5.09E+01 6.31E+01 0.00E+00 0.00E+00 0.00E+00
/// -14  1 1 2 0 0 -1.39E+01 -3.82E+01  4.55E+01 6.10E+01 0.00E+00 0.00E+00 0.00E+00
///   5  1 1 2 0 0 -5.55E+01 -3.47E+01  4.73E+01 8.08E+01 0.00E+00 0.00E+00 0.00E+00
///  -5  1 1 2 0 0  9.87E+01 -2.06E+01  4.60E+02 4.71E+02 0.00E+00 0.00E+00 0.00E+00
/// ## pdf 1.51E-01 7.18E-03 1.73E+02
/// ## me 4 3 -1.97E-07 5.74E-01 5.98E-01 2.60E-09 -3.42E-10 5.51E-08 -5.57E-09 0.00E+00 0.00E+00 -5.73E-08 5.92E-09 3.06E-09 -4.06E-10 6.93E-08 -7.06E-09 0.00E+00 0.00E+00 -6.75E-08 7.27E-09
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFileKP::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let me = &event.extra.me;
/// assert_eq!(me.weight, -1.97e-7);
/// assert_eq!(me.x1_prime, 0.574);
/// assert_eq!(me.weight_a2g_l0, 3.06e-9);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct MeInfoKP {
    /// Electroweak coupling power
    pub max_ew: u8,
    /// Strong coupling power
    pub max_qcd: u8,
    /// Total weight of the event
    pub weight: f64,
    /// Factor for `x1` for the rescaled event
    pub x1_prime: f64,
    /// Factor for `x2` for the rescaled event
    pub x2_prime: f64,
    pub weight_a1g_l0: f64,
    pub weight_a1g_l1: f64,
    pub weight_a1q_l0: f64,
    pub weight_a1q_l1: f64,
    pub weight_b1g_l0: f64,
    pub weight_b1g_l1: f64,
    pub weight_b1q_l0: f64,
    pub weight_b1q_l1: f64,
    pub weight_a2g_l0: f64,
    pub weight_a2g_l1: f64,
    pub weight_a2q_l0: f64,
    pub weight_a2q_l1: f64,
    pub weight_b2g_l0: f64,
    pub weight_b2g_l1: f64,
    pub weight_b2q_l0: f64,
    pub weight_b2q_l1: f64,
}

impl ReadLhe for MeInfoKP {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], MeInfoKP> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("me")) >> max_ew: ws!(parse_u8) >> max_qcd: ws!(parse_u8)
                >> weight: ws!(parse_f64) >> x1_prime: ws!(parse_f64)
                >> x2_prime: ws!(parse_f64) >> weight_a1g_l0: ws!(parse_f64)
                >> weight_a1g_l1: ws!(parse_f64) >> weight_a1q_l0: ws!(parse_f64)
                >> weight_a1q_l1: ws!(parse_f64) >> weight_b1g_l0: ws!(parse_f64)
                >> weight_b1g_l1: ws!(parse_f64) >> weight_b1q_l0: ws!(parse_f64)
                >> weight_b1q_l1: ws!(parse_f64) >> weight_a2g_l0: ws!(parse_f64)
                >> weight_a2g_l1: ws!(parse_f64) >> weight_a2q_l0: ws!(parse_f64)
                >> weight_a2q_l1: ws!(parse_f64) >> weight_b2g_l0: ws!(parse_f64)
                >> weight_b2g_l1: ws!(parse_f64) >> weight_b2q_l0: ws!(parse_f64)
                >> weight_b2q_l1: ws!(parse_f64) >> (MeInfoKP {
                max_ew,
                max_qcd,
                weight,
                x1_prime,
                x2_prime,
                weight_a1g_l0,
                weight_a1g_l1,
                weight_a1q_l0,
                weight_a1q_l1,
                weight_b1g_l0,
                weight_b1g_l1,
                weight_b1q_l0,
                weight_b1q_l1,
                weight_a2g_l0,
                weight_a2g_l1,
                weight_a2q_l0,
                weight_a2q_l1,
                weight_b2g_l0,
                weight_b2g_l1,
                weight_b2q_l0,
                weight_b2q_l1,
            })
        )
    }
}

impl WriteLhe for MeInfoKP {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        write!(
            writer,
            "# me {} {} {:e} {:e} {:e}",
            self.max_ew, self.max_qcd, self.weight, self.x1_prime, self.x2_prime
        )?;
        write!(
            writer,
            " {:e} {:e} {:e} {:e} {:e} {:e} {:e} {:e}",
            self.weight_a1g_l0,
            self.weight_a1g_l1,
            self.weight_a1q_l0,
            self.weight_a1q_l1,
            self.weight_b1g_l0,
            self.weight_b1g_l1,
            self.weight_b1q_l0,
            self.weight_b1q_l1,
        )?;
        writeln!(
            writer,
            " {:e} {:e} {:e} {:e} {:e} {:e} {:e} {:e}",
            self.weight_a2g_l0,
            self.weight_a2g_l1,
            self.weight_a2q_l0,
            self.weight_a2q_l1,
            self.weight_b2g_l0,
            self.weight_b2g_l1,
            self.weight_b2q_l0,
            self.weight_b2q_l1,
        )
    }
}

#[cfg(test)]
impl Arbitrary for MeInfoKP {
    fn arbitrary<G: Gen>(gen: &mut G) -> MeInfoKP {
        MeInfoKP {
            max_ew: Arbitrary::arbitrary(gen),
            max_qcd: Arbitrary::arbitrary(gen),
            weight: Arbitrary::arbitrary(gen),
            x1_prime: Arbitrary::arbitrary(gen),
            x2_prime: Arbitrary::arbitrary(gen),
            weight_a1g_l0: Arbitrary::arbitrary(gen),
            weight_a1g_l1: Arbitrary::arbitrary(gen),
            weight_a1q_l0: Arbitrary::arbitrary(gen),
            weight_a1q_l1: Arbitrary::arbitrary(gen),
            weight_b1g_l0: Arbitrary::arbitrary(gen),
            weight_b1g_l1: Arbitrary::arbitrary(gen),
            weight_b1q_l0: Arbitrary::arbitrary(gen),
            weight_b1q_l1: Arbitrary::arbitrary(gen),
            weight_a2g_l0: Arbitrary::arbitrary(gen),
            weight_a2g_l1: Arbitrary::arbitrary(gen),
            weight_a2q_l0: Arbitrary::arbitrary(gen),
            weight_a2q_l1: Arbitrary::arbitrary(gen),
            weight_b2g_l0: Arbitrary::arbitrary(gen),
            weight_b2g_l1: Arbitrary::arbitrary(gen),
            weight_b2q_l0: Arbitrary::arbitrary(gen),
            weight_b2q_l1: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional initialization information used for the LO+Virtual part
///
/// Event files generated by HELAC-1LOOP are slightly different than the
/// ones generated by HELAC-DIPOLES.
/// Unlike HELAC-DIPOLES, the cross section stored in the `ProcInfo`
/// part of the `init` section is actually the cross section itself.
/// The cross section normalized to the average weight is also included
/// and is stored in the `# NORM` line in the extra init information
/// and in the `Norm` struct, when read using this library.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFile1loop;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-1LOOP_v2.2
/// Type: LO+V
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 3.82E-02 2.87E-05 1.00E+00 81
/// ## NORM 100000 3.82E-02 2.91E-05
/// ## SUMPDF 2 1 -1 3 -3
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile1loop::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let extra = &init.extra;
/// assert_eq!(extra.norm.alpha, 3.82e-2);
/// assert_eq!(extra.norm.alpha_err, 2.91e-5);
/// assert_eq!(extra.pdf_sum.pdf_sum_pairs[0], (1,-1));
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct InitExtra1loop {
    /// Additional information about possible pdf summation (`# SUMPDF`)
    pub pdf_sum: PdfSum,
    /// Normalization information when using partial unweighting (`# NORM`)
    pub norm: Norm,
}

impl ReadLhe for InitExtra1loop {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], InitExtra1loop> {
        do_parse!(
            input,
            ex: permutation!(ws!(PdfSum::read_lhe), ws!(Norm::read_lhe)) >> (InitExtra1loop {
                pdf_sum: ex.0,
                norm: ex.1,
            })
        )
    }
}

impl WriteLhe for InitExtra1loop {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.norm.write_lhe(writer)?;
        self.pdf_sum.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for InitExtra1loop {
    fn arbitrary<G: Gen>(gen: &mut G) -> InitExtra1loop {
        InitExtra1loop {
            pdf_sum: Arbitrary::arbitrary(gen),
            norm: Arbitrary::arbitrary(gen),
        }
    }
}

/// Normalization information when using partial unweighting
///
/// This struct contains information about the results of the partial
/// unweighting procedure.
/// It contains the number of events generated, as well as the cross
/// section devided by the average weight and the error on this value.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFile1loop;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-1LOOP_v2.2
/// Type: LO+V
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 3.82E-02 2.87E-05 1.00E+00 81
/// ## NORM 100000 3.82E-02 2.91E-05
/// ## SUMPDF 2 1 -1 3 -3
/// </init>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile1loop::read_lhe(bytes).to_full_result().unwrap();
///
/// let init = &lhe.init;
/// let norm = &init.extra.norm;
/// assert_eq!(norm.alpha, 3.82e-2);
/// assert_eq!(norm.alpha_err, 2.91e-5);
/// assert_eq!(norm.n_unweighted_events, 100000);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct Norm {
    /// The number of unweighted events that have been generated
    pub n_unweighted_events: u64,
    /// The cross section divided by the average weight of the events in the file
    pub alpha: f64,
    /// The uncertainty on `alpha`
    pub alpha_err: f64,
}

impl ReadLhe for Norm {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], Norm> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("NORM")) >> n_unweighted_events: ws!(parse_u64)
                >> alpha: ws!(parse_f64) >> alpha_err: ws!(parse_f64) >> (Norm {
                n_unweighted_events,
                alpha,
                alpha_err,
            })
        )
    }
}

impl WriteLhe for Norm {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "# NORM {} {:e} {:e}",
            self.n_unweighted_events, self.alpha, self.alpha_err
        )
    }
}

#[cfg(test)]
impl Arbitrary for Norm {
    fn arbitrary<G: Gen>(gen: &mut G) -> Norm {
        Norm {
            n_unweighted_events: Arbitrary::arbitrary(gen),
            alpha: Arbitrary::arbitrary(gen),
            alpha_err: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional event information for the LO+VIRTUAL part
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFile1loop;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-1LOOP_v2.2
/// Type: LO+V
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 3.82E-02 2.87E-05 1.00E+00 81
/// ## NORM 100000 3.82E-02 2.91E-05
/// ## SUMPDF 2 1 -1 3 -3
/// </init>
/// <event>
/// 8 81 1.17E+00 1.73E+02 7.56E-03 1.07E-01
///   1 -1 0 0 102   0  0.00E+00  0.00E+00  4.84E+02 4.84E+02 0.00E+00 0.00E+00 9.00E+00
///  -1 -1 0 0   0 101  0.00E+00  0.00E+00 -3.84E+02 3.84E+02 0.00E+00 0.00E+00 9.00E+00
/// -11  1 1 2   0   0 -1.25E+02 -7.31E+01  1.21E+01 1.45E+02 0.00E+00 0.00E+00 9.00E+00
///  12  1 1 2   0   0  1.26E+01 -1.27E+01  2.55E+00 1.81E+01 0.00E+00 0.00E+00 9.00E+00
///  13  1 1 2   0   0  7.78E+01  9.57E+01 -1.46E+00 1.23E+02 0.00E+00 0.00E+00 9.00E+00
/// -14  1 1 2   0   0 -7.47E+00  8.68E+01  3.09E+01 9.24E+01 0.00E+00 0.00E+00 9.00E+00
///   5  1 1 2 102   0 -1.06E+02 -2.29E+02 -5.88E+01 2.59E+02 0.00E+00 0.00E+00 9.00E+00
///  -5  1 1 2   0 101  1.48E+02  1.32E+02  1.14E+02 2.29E+02 0.00E+00 0.00E+00 9.00E+00
/// ## pdf 7.45E-02 5.91E-02 1.73E+02
/// ## me 4 2 9.40E-09 4 3 1.62E-09 -6.47E-08 1.08E-08 -4.29E-10
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile1loop::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let extra = &event.extra;
/// assert_eq!(extra.pdf.x2, 5.91e-2);
/// assert_eq!(extra.me.weight_lo, 9.40e-9);
/// assert_eq!(extra.me.weight_1loop, 1.62e-9);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct EventExtra1loop {
    /// Additional pdf information (`# pdf`)
    pub pdf: PdfInfo,
    /// Additional matrix element information (`# me`)
    pub me: MeInfo1loop,
}

impl ReadLhe for EventExtra1loop {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], EventExtra1loop> {
        do_parse!(
            input,
            ex: permutation!(ws!(PdfInfo::read_lhe), ws!(MeInfo1loop::read_lhe))
                >> (EventExtra1loop {
                    pdf: ex.0,
                    me: ex.1,
                })
        )
    }
}

impl WriteLhe for EventExtra1loop {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        self.pdf.write_lhe(writer)?;
        self.me.write_lhe(writer)
    }
}

#[cfg(test)]
impl Arbitrary for EventExtra1loop {
    fn arbitrary<G: Gen>(gen: &mut G) -> EventExtra1loop {
        EventExtra1loop {
            pdf: Arbitrary::arbitrary(gen),
            me: Arbitrary::arbitrary(gen),
        }
    }
}

/// Additional matrix element level information for the LO+Virtual part
///
/// This struct contains both weights for the LO and for the Virtual
/// piece.
///
/// The coefficients can be used to reconstruct the Virtual weight, as
/// might be needed for reweighting events.
/// See the example for how this is done.
///
/// # Examples
///
/// ```
/// use lhef::ReadLhe;
/// use lhef::helac::LheFile1loop;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <!--
/// File generated with HELAC-1LOOP_v2.2
/// Type: LO+V
/// -->
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 3.82E-02 2.87E-05 1.00E+00 81
/// ## NORM 100000 3.82E-02 2.91E-05
/// ## SUMPDF 2 1 -1 3 -3
/// </init>
/// <event>
/// 8 81 1.173294414273079E+00 1.732000000000000E+02 7.562391098139707E-03 1.076105351933744E-01
///   1 -1 0 0 102   0  0.00E+00  0.00E+00  4.84E+02 4.84E+02 0.00E+00 0.00E+00 9.00E+00
///  -1 -1 0 0   0 101  0.00E+00  0.00E+00 -3.84E+02 3.84E+02 0.00E+00 0.00E+00 9.00E+00
/// -11  1 1 2   0   0 -1.25E+02 -7.31E+01  1.21E+01 1.45E+02 0.00E+00 0.00E+00 9.00E+00
///  12  1 1 2   0   0  1.26E+01 -1.27E+01  2.55E+00 1.81E+01 0.00E+00 0.00E+00 9.00E+00
///  13  1 1 2   0   0  7.78E+01  9.57E+01 -1.46E+00 1.23E+02 0.00E+00 0.00E+00 9.00E+00
/// -14  1 1 2   0   0 -7.47E+00  8.68E+01  3.09E+01 9.24E+01 0.00E+00 0.00E+00 9.00E+00
///   5  1 1 2 102   0 -1.06E+02 -2.29E+02 -5.88E+01 2.59E+02 0.00E+00 0.00E+00 9.00E+00
///  -5  1 1 2   0 101  1.48E+02  1.32E+02  1.14E+02 2.29E+02 0.00E+00 0.00E+00 9.00E+00
/// ## pdf 7.45E-02 5.91E-02 1.73E+02
/// ## me 4 2 9.404757596083406E-09 4 3 1.629791958993560E-09 -6.476318714960301E-08 1.08683154808454E-08 -4.295277840991483E-10
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile1loop::read_lhe(bytes).to_full_result().unwrap();
///
/// let event = &lhe.events[0];
/// let me = &event.extra.me;
/// assert_eq!(me.weight_lo, 9.404757596083406E-09);
/// assert_eq!(me.weight_1loop, 1.629791958993560E-09);
///
/// // Reconstructing the virtual weight
/// let log = (event.scale.powi(2)).ln();
/// let weight = me.coeff_a + me.coeff_b * log + me.coeff_c * log.powi(2);
/// assert!((me.weight_1loop - weight)/me.weight_1loop < 1e-9);
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct MeInfo1loop {
    /// Electroweak coupling power at leading order
    pub max_ew_lo: i64,
    /// Strong coupling power at leading order
    pub max_qcd_lo: i64,
    /// The leading order weight of the event
    pub weight_lo: f64,
    /// Electroweak coupling power at the 1loop level
    pub max_ew_1loop: i64,
    /// Strong coupling power at the 1loop level
    pub max_qcd_1loop: i64,
    /// The weight of the event at 1loop level
    pub weight_1loop: f64,
    /// The constant part of the matrix element
    pub coeff_a: f64,
    /// The coefficient of the `log(mu_r^2)` part of the 1loop matrix element
    pub coeff_b: f64,
    /// The coefficient of the `log(mu_r^2)^2` part of the 1loop matrix element
    pub coeff_c: f64,
}

impl ReadLhe for MeInfo1loop {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], MeInfo1loop> {
        do_parse!(
            input,
            ws!(tag!("#")) >> ws!(tag!("me")) >> max_ew_lo: ws!(parse_i64)
                >> max_qcd_lo: ws!(parse_i64) >> weight_lo: ws!(parse_f64)
                >> max_ew_1loop: ws!(parse_i64) >> max_qcd_1loop: ws!(parse_i64)
                >> weight_1loop: ws!(parse_f64) >> coeff_a: ws!(parse_f64)
                >> coeff_b: ws!(parse_f64) >> coeff_c: ws!(parse_f64)
                >> (MeInfo1loop {
                    max_ew_lo,
                    max_qcd_lo,
                    weight_lo,
                    max_ew_1loop,
                    max_qcd_1loop,
                    weight_1loop,
                    coeff_a,
                    coeff_b,
                    coeff_c,
                })
        )
    }
}

impl WriteLhe for MeInfo1loop {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "# me {} {} {:e} {} {} {:e} {:e} {:e} {:e}",
            self.max_ew_lo,
            self.max_qcd_lo,
            self.weight_lo,
            self.max_ew_1loop,
            self.max_qcd_1loop,
            self.weight_1loop,
            self.coeff_a,
            self.coeff_b,
            self.coeff_c,
        )
    }
}

#[cfg(test)]
impl Arbitrary for MeInfo1loop {
    fn arbitrary<G: Gen>(gen: &mut G) -> MeInfo1loop {
        MeInfo1loop {
            max_ew_lo: Arbitrary::arbitrary(gen),
            max_qcd_lo: Arbitrary::arbitrary(gen),
            weight_lo: Arbitrary::arbitrary(gen),
            max_ew_1loop: Arbitrary::arbitrary(gen),
            max_qcd_1loop: Arbitrary::arbitrary(gen),
            weight_1loop: Arbitrary::arbitrary(gen),
            coeff_a: Arbitrary::arbitrary(gen),
            coeff_b: Arbitrary::arbitrary(gen),
            coeff_c: Arbitrary::arbitrary(gen),
        }
    }
}

#[cfg(test)]
mod tests {
    use quickcheck;
    use serde_json;
    use std::fs;
    use std::str;

    use {ReadLhe, WriteLhe};
    use super::*;

    macro_rules! roundtrip_qc {
        ($name:ident, $ty:ident) => {
            quickcheck! {
                fn $name(start: $ty) -> quickcheck::TestResult {
                    let mut bytes = Vec::new();
                    start.write_lhe(&mut bytes).unwrap();
                        let round = match $ty::read_lhe(&bytes).to_full_result() {
                        Ok(r) => r,
                        Err(err) => {
                            println!("{}", str::from_utf8(&bytes).unwrap());
                            panic!("Failed to read roundtrip: {:?}", err);
                        },
                    };
                    if start == round {
                        quickcheck::TestResult::passed()
                    } else {
                        println!("After: {:?}", round);
                        quickcheck::TestResult::failed()
                    }
                }
            }
        }
    }

    roundtrip_qc!(comment_roundtrip_qc, Comment);
    roundtrip_qc!(pdfsum_roundtrip_qc, PdfSum);
    roundtrip_qc!(pdfinfo_roundtrip_qc, PdfInfo);
    roundtrip_qc!(jetalgo_roundtrip_qc, JetAlgoInfo);
    roundtrip_qc!(dipmap_roundtrip_qc, DipMapInfo);
    roundtrip_qc!(initextrars_roundtrip_qc, InitExtraRS);
    roundtrip_qc!(meinfors_roundtrip_qc, MeInfoRS);
    roundtrip_qc!(jetinfo_roundtrip_qc, JetInfo);
    roundtrip_qc!(eventextrars_roundtrip_qc, EventExtraRS);
    roundtrip_qc!(meinfoi_roundtrip_qc, MeInfoI);
    roundtrip_qc!(eventextrai_roundtrip_qc, EventExtraI);
    roundtrip_qc!(pdfsumkp_roundtrip_qc, PdfSumKP);
    roundtrip_qc!(meinfokp_roundtrip_qc, MeInfoKP);
    roundtrip_qc!(eventextrakp_roundtrip_qc, EventExtraKP);
    roundtrip_qc!(norm_roundtrip_qc, Norm);
    roundtrip_qc!(initextra1loop_roundtrip_qc, InitExtra1loop);
    roundtrip_qc!(meinfo1loop_roundtrip_qc, MeInfo1loop);
    roundtrip_qc!(eventextra1loop_roundtrip_qc, EventExtra1loop);

    #[test]
    fn meinfors_roundtrip() {
        let start = MeInfoRS {
            weight: 1.,
            max_ew: 2,
            max_qcd: 3,
            real_weight: 4.,
            scale: 5.,
            dipole_ids: vec![7],
            dipole_weights: vec![8.],
            dipole_mu_rs: Some(vec![9.]),
        };
        let mut bytes = Vec::new();
        start.write_lhe(&mut bytes).unwrap();
        let round = match MeInfoRS::read_lhe(&bytes).to_full_result() {
            Ok(r) => r,
            Err(err) => {
                println!("{}", str::from_utf8(&bytes).unwrap());
                panic!("Failed to read roundtrip: {:?}", err);
            }
        };
        if start != round {
            println!("After: {:?}", round);
            assert_eq!(start, round);
        }
    }

    #[test]
    fn read_comment() {
        let bytes = b"<!--
File generated with HELAC-DIPOLES
-->";
        let expected = Comment("File generated with HELAC-DIPOLES".to_string());
        let comment = Comment::read_lhe(bytes as &[u8]).to_full_result().unwrap();
        assert_eq!(comment, expected);
    }

    #[test]
    fn read_pdfsum() {
        let bytes = b"# SUMPDF 4 1 2 3 4 -1 -2 0 8\n";
        let expected = PdfSum {
            pdf_sum_pairs: vec![(1, 2), (3, 4), (-1, -2), (0, 8)],
        };
        let result = PdfSum::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_pdfsum_empty() {
        let bytes = b"# SUMPDF 0\n";
        let expected = PdfSum {
            pdf_sum_pairs: vec![],
        };
        let result = PdfSum::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_pdfinfo() {
        let bytes = b"# pdf 1.0 2.0 3.0\n";
        let expected = PdfInfo {
            x1: 1.0,
            x2: 2.0,
            scale: 3.0,
        };
        let result = PdfInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_jetalgoinfo_true() {
        let bytes = b"# JETALGO 1 2 3. 4. T 5.\n";
        let expected = JetAlgoInfo {
            algorithm_id: 1,
            n_bjets: 2,
            eta_max: 3.,
            dr: 4.,
            pt_veto: Some(5.),
        };
        let result = JetAlgoInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_jetalgoinfo_false() {
        let bytes = b"# JETALGO 1 2 3. 4. F 5.\n";
        let expected = JetAlgoInfo {
            algorithm_id: 1,
            n_bjets: 2,
            eta_max: 3.,
            dr: 4.,
            pt_veto: None,
        };
        let result = JetAlgoInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_dipmap() {
        let bytes = b"# DIPMAP 1   9  1  7  1  8  1  9  2  7  2  8  2  9  7  8  7  9  8  9\n";
        let expected = DipMapInfo {
            dipole_type: 1,
            dipole_map: vec![
                (1, 7),
                (1, 8),
                (1, 9),
                (2, 7),
                (2, 8),
                (2, 9),
                (7, 8),
                (7, 9),
                (8, 9),
            ],
        };
        let result = DipMapInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_initextrars() {
        let bytes_normal = b"# SUMPDF 4 1 2 3 4 -1 -2 0 8\n# DIPMAP 1   9  1  7  1  8  1  9  2  7  2  8  2  9  7  8  7  9  8  9\n# JETALGO 1 2 3. 4. F 5.\n";
        let bytes_reverse = b"# JETALGO 1 2 3. 4. F 5.\n# DIPMAP 1   9  1  7  1  8  1  9  2  7  2  8  2  9  7  8  7  9  8  9\n# SUMPDF 4 1 2 3 4 -1 -2 0 8\n";
        let expected = InitExtraRS {
            pdf_sum: PdfSum {
                pdf_sum_pairs: vec![(1, 2), (3, 4), (-1, -2), (0, 8)],
            },
            dip_map: DipMapInfo {
                dipole_type: 1,
                dipole_map: vec![
                    (1, 7),
                    (1, 8),
                    (1, 9),
                    (2, 7),
                    (2, 8),
                    (2, 9),
                    (7, 8),
                    (7, 9),
                    (8, 9),
                ],
            },
            jet_algo: JetAlgoInfo {
                algorithm_id: 1,
                n_bjets: 2,
                eta_max: 3.,
                dr: 4.,
                pt_veto: None,
            },
        };
        let result_normal = InitExtraRS::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = InitExtraRS::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_meinfors() {
        let bytes = b"# me 13. 1 6 3. 4. 5 2 7 8 9. 10. 11. 12.\n";
        let expected = MeInfoRS {
            weight: 13.,
            max_ew: 1,
            max_qcd: 6,
            real_weight: 3.,
            scale: 4.,
            dipole_ids: vec![7, 8],
            dipole_weights: vec![9., 10.],
            dipole_mu_rs: Some(vec![11., 12.]),
        };
        let result = MeInfoRS::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_meinfors_irun0() {
        let bytes = b"# me 13. 1 6 3. 4. 0 2 7 8 9. 10. 11. 12.\n";
        let expected = MeInfoRS {
            weight: 13.,
            max_ew: 1,
            max_qcd: 6,
            real_weight: 3.,
            scale: 4.,
            dipole_ids: vec![7, 8],
            dipole_weights: vec![9., 10.],
            dipole_mu_rs: None,
        };
        let result = MeInfoRS::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_jetinfo() {
        let bytes = b"# jet 1 2 3\n";
        let expected = JetInfo {
            ibvjet1: 1,
            ibvjet2: 2,
            ibvflreco: 3,
        };
        let result = JetInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_eventextrars() {
        let bytes_normal =
            b"# pdf 1.0 2.0 3.0\n# me 13. 1 6 3. 4. 5 2 7 8 9. 10. 11. 12.\n# jet 1 2 3\n";
        let bytes_reverse =
            b"# jet 1 2 3\n# me 13. 1 6 3. 4. 5 2 7 8 9. 10. 11. 12.\n# pdf 1.0 2.0 3.0\n";
        let expected = EventExtraRS {
            pdf: PdfInfo {
                x1: 1.0,
                x2: 2.0,
                scale: 3.0,
            },
            me: MeInfoRS {
                weight: 13.,
                max_ew: 1,
                max_qcd: 6,
                real_weight: 3.,
                scale: 4.,
                dipole_ids: vec![7, 8],
                dipole_weights: vec![9., 10.],
                dipole_mu_rs: Some(vec![11., 12.]),
            },
            jet: JetInfo {
                ibvjet1: 1,
                ibvjet2: 2,
                ibvflreco: 3,
            },
        };
        let result_normal = EventExtraRS::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = EventExtraRS::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_meinfoi() {
        let bytes = b"# me 1 2 3. 4. 5. 6. 7\n";
        let expected = MeInfoI {
            max_ew: 1,
            max_qcd: 2,
            weight: 3.,
            coeff_a: 4.,
            coeff_b: 5.,
            coeff_c: 6.,
            log_term: 7,
        };
        let result = MeInfoI::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_eventextrai() {
        let bytes_normal = b"# pdf 1.0 2.0 3.0\n# me 1 2 3. 4. 5. 6. 7\n";
        let bytes_reverse = b"# me 1 2 3. 4. 5. 6. 7\n# pdf 1.0 2.0 3.0\n";
        let expected = EventExtraI {
            pdf: PdfInfo {
                x1: 1.0,
                x2: 2.0,
                scale: 3.0,
            },
            me: MeInfoI {
                max_ew: 1,
                max_qcd: 2,
                weight: 3.,
                coeff_a: 4.,
                coeff_b: 5.,
                coeff_c: 6.,
                log_term: 7,
            },
        };
        let result_normal = EventExtraI::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = EventExtraI::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_pdfsumkp() {
        let bytes = b"# SUMPDF 1 2 0 3 4 5 6 7 8 9 10\n";
        let expected = PdfSumKP {
            beam_1_gluon_id: Some(4),
            beam_2_gluon_id: None,
            beam_1_quark_ids: vec![5, 6],
            beam_2_quark_ids: vec![8, 9, 10],
        };
        let result = PdfSumKP::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_meinfokp() {
        let bytes =
            b"# me 1 2 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21.\n";
        let expected = MeInfoKP {
            max_ew: 1,
            max_qcd: 2,
            weight: 3.,
            x1_prime: 4.,
            x2_prime: 5.,
            weight_a1g_l0: 6.,
            weight_a1g_l1: 7.,
            weight_a1q_l0: 8.,
            weight_a1q_l1: 9.,
            weight_b1g_l0: 10.,
            weight_b1g_l1: 11.,
            weight_b1q_l0: 12.,
            weight_b1q_l1: 13.,
            weight_a2g_l0: 14.,
            weight_a2g_l1: 15.,
            weight_a2q_l0: 16.,
            weight_a2q_l1: 17.,
            weight_b2g_l0: 18.,
            weight_b2g_l1: 19.,
            weight_b2q_l0: 20.,
            weight_b2q_l1: 21.,
        };
        let result = MeInfoKP::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_eventextrakp() {
        let bytes_normal = b"# pdf 1.0 2.0 3.0\n# me 1 2 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21.\n";
        let bytes_reverse = b"# me 1 2 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21.\n# pdf 1.0 2.0 3.0\n";
        let expected = EventExtraKP {
            pdf: PdfInfo {
                x1: 1.0,
                x2: 2.0,
                scale: 3.0,
            },
            me: MeInfoKP {
                max_ew: 1,
                max_qcd: 2,
                weight: 3.,
                x1_prime: 4.,
                x2_prime: 5.,
                weight_a1g_l0: 6.,
                weight_a1g_l1: 7.,
                weight_a1q_l0: 8.,
                weight_a1q_l1: 9.,
                weight_b1g_l0: 10.,
                weight_b1g_l1: 11.,
                weight_b1q_l0: 12.,
                weight_b1q_l1: 13.,
                weight_a2g_l0: 14.,
                weight_a2g_l1: 15.,
                weight_a2q_l0: 16.,
                weight_a2q_l1: 17.,
                weight_b2g_l0: 18.,
                weight_b2g_l1: 19.,
                weight_b2q_l0: 20.,
                weight_b2q_l1: 21.,
            },
        };
        let result_normal = EventExtraKP::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = EventExtraKP::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_norm() {
        let bytes = b"# NORM 1 2. 3.\n";
        let expected = Norm {
            n_unweighted_events: 1,
            alpha: 2.,
            alpha_err: 3.,
        };
        let result = Norm::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_initextra1loop() {
        let bytes_normal = b"# NORM 1 2. 3.\n# SUMPDF 4 1 2 3 4 -1 -2 0 8\n";
        let bytes_reverse = b"# SUMPDF 4 1 2 3 4 -1 -2 0 8\n# NORM 1 2. 3.\n";
        let expected = InitExtra1loop {
            pdf_sum: PdfSum {
                pdf_sum_pairs: vec![(1, 2), (3, 4), (-1, -2), (0, 8)],
            },
            norm: Norm {
                n_unweighted_events: 1,
                alpha: 2.,
                alpha_err: 3.,
            },
        };
        let result_normal = InitExtra1loop::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = InitExtra1loop::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_meinfo1loop() {
        let bytes = b"# me 1 2 3. 4 5 6. 7. 8. 9.\n";
        let expected = MeInfo1loop {
            max_ew_lo: 1,
            max_qcd_lo: 2,
            weight_lo: 3.,
            max_ew_1loop: 4,
            max_qcd_1loop: 5,
            weight_1loop: 6.,
            coeff_a: 7.,
            coeff_b: 8.,
            coeff_c: 9.,
        };
        let result = MeInfo1loop::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_eventextra1loop() {
        let bytes_normal = b"# pdf 1.0 2.0 3.0\n# me 1 2 3. 4 5 6. 7. 8. 9.\n";
        let bytes_reverse = b"# me 1 2 3. 4 5 6. 7. 8. 9.\n# pdf 1.0 2.0 3.0\n";
        let expected = EventExtra1loop {
            pdf: PdfInfo {
                x1: 1.0,
                x2: 2.0,
                scale: 3.0,
            },
            me: MeInfo1loop {
                max_ew_lo: 1,
                max_qcd_lo: 2,
                weight_lo: 3.,
                max_ew_1loop: 4,
                max_qcd_1loop: 5,
                weight_1loop: 6.,
                coeff_a: 7.,
                coeff_b: 8.,
                coeff_c: 9.,
            },
        };
        let result_normal = EventExtra1loop::read_lhe(bytes_normal)
            .to_full_result()
            .unwrap();
        assert_eq!(result_normal, expected);
        let result_reverse = EventExtra1loop::read_lhe(bytes_reverse)
            .to_full_result()
            .unwrap();
        assert_eq!(result_reverse, expected);
    }

    #[test]
    fn read_rs() {
        LheFileRS::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_rs.lhe").unwrap();
    }

    #[test]
    fn validate_rs() {
        let lhe =
            LheFileRS::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_rs.lhe").unwrap();
        let mut file = fs::File::open("tests/real_world_files/helac_dipoles_rs.json").unwrap();
        let valid: LheFileRS = serde_json::from_reader(&mut file).unwrap();
        assert_eq!(lhe, valid);
    }

    #[test]
    fn roundtrip_rs() {
        let lhe =
            match LheFileRS::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_rs.lhe") {
                Ok(l) => l,
                Err(e) => panic!("Failed to read: {:?}", e),
            };

        let mut bytes = Vec::new();
        lhe.write_lhe(&mut bytes).unwrap();
        let round = match LheFileRS::read_lhe(&bytes).to_full_result() {
            Ok(l) => l,
            Err(e) => panic!("Failed to read roundtrip: {:?}", e),
        };
        assert_eq!(lhe, round);
    }

    #[test]
    fn read_i() {
        LheFileI::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_i.lhe").unwrap();
    }

    #[test]
    fn roundtrip_i() {
        let lhe = match LheFileI::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_i.lhe")
        {
            Ok(l) => l,
            Err(e) => panic!("Failed to read: {:?}", e),
        };

        let mut bytes = Vec::new();
        lhe.write_lhe(&mut bytes).unwrap();
        let round = match LheFileI::read_lhe(&bytes).to_full_result() {
            Ok(l) => l,
            Err(e) => panic!("Failed to read roundtrip: {:?}", e),
        };
        assert_eq!(lhe, round);
    }

    #[test]
    fn validate_i() {
        let lhe =
            LheFileI::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_i.lhe").unwrap();
        let mut file = fs::File::open("tests/real_world_files/helac_dipoles_i.json").unwrap();
        let valid: LheFileI = serde_json::from_reader(&mut file).unwrap();
        assert_eq!(lhe, valid);
    }

    #[test]
    fn read_kp() {
        LheFileKP::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_kp.lhe").unwrap();
    }

    #[test]
    fn roundtrip_kp() {
        let lhe =
            match LheFileKP::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_kp.lhe") {
                Ok(l) => l,
                Err(e) => panic!("Failed to read: {:?}", e),
            };

        let mut bytes = Vec::new();
        lhe.write_lhe(&mut bytes).unwrap();
        let round = match LheFileKP::read_lhe(&bytes).to_full_result() {
            Ok(l) => l,
            Err(e) => panic!("Failed to read roundtrip: {:?}", e),
        };
        assert_eq!(lhe, round);
    }

    #[test]
    fn validate_kp() {
        let lhe =
            LheFileKP::read_lhe_from_file(&"tests/real_world_files/helac_dipoles_kp.lhe").unwrap();
        let mut file = fs::File::open("tests/real_world_files/helac_dipoles_kp.json").unwrap();
        let valid: LheFileKP = serde_json::from_reader(&mut file).unwrap();
        assert_eq!(lhe, valid);
    }

    #[test]
    fn read_1loop() {
        LheFile1loop::read_lhe_from_file(&"tests/real_world_files/helac_1loop_virt.lhe").unwrap();
    }

    #[test]
    fn roundtrip_1loop() {
        let lhe = match LheFile1loop::read_lhe_from_file(
            &"tests/real_world_files/helac_1loop_virt.lhe",
        ) {
            Ok(l) => l,
            Err(e) => panic!("Failed to read: {:?}", e),
        };

        let mut bytes = Vec::new();
        lhe.write_lhe(&mut bytes).unwrap();
        let round = match LheFile1loop::read_lhe(&bytes).to_full_result() {
            Ok(l) => l,
            Err(e) => panic!("Failed to read roundtrip: {:?}", e),
        };
        assert_eq!(lhe, round);
    }

    #[test]
    fn validate_1loop() {
        let lhe = LheFile1loop::read_lhe_from_file(&"tests/real_world_files/helac_1loop_virt.lhe")
            .unwrap();
        let mut file = fs::File::open("tests/real_world_files/helac_1loop_virt.json").unwrap();
        let valid: LheFile1loop = serde_json::from_reader(&mut file).unwrap();
        assert_eq!(lhe, valid);
    }
}
