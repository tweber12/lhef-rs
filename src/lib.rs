// Copyright 2018 Torsten Weber
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! # LHEF
//!
//! The `lhef` library is a [`rust`] library to read and write files in
//! the [`LesHouchesEvents`] format.
//! It can be used to just read the common blocks specified by the
//! standard, but is flexible enough to also handle the additional
//! information that is allowed by the standard.
//! This can be done either by reading them as `String`s or by parsing
//! them into custom data structures.
//! Reading common blocks has been tested for event files generated by
//! [`MG5_aMC@NLO`] and [`HELAC_NLO`].
//! Specialized data structures for the reweighting information written
//! by `HELAC_NLO` are included.
//!
//! ## Usage examples
//!
//! ### Reading a file and ignoring all extra information:
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::plain::LheFile;
//!
//! let lhe = LheFile::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // Energy of beam 1
//! let beam_1_energy = lhe.init.beam_1_energy;
//!
//! // pz of the 4rd particle in the 7th event
//! let pz = lhe.events[6].particles[3].momentum.pz;
//! ```
//!
//! ### Reading a file generated including extra information as strings:
//!
//! Specialized data structures for e.g. Madgraph do not exist, but the
//! additional information stored in the event files written by it can
//! still be extracted as strings:
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::string::{LheFile, EventExtra};
//!
//! let lhe = LheFile::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // extra information of the 5th event
//! let EventExtra(ref extra) = lhe.events[4].extra;
//! ```
//!
//! ### Reading a file generated by `HELAC-NLO`
//!
//! This library comes with a module containing special data structures
//! for the additional information contained in event files generated by
//! `HELAC-NLO`.
//! Therefore event files generated by `HELAC` can be read directly into
//! the appropriate structures:
//!
//! ```rust,ignore
//! use lhef::ReadLhe;
//! use lhef::helac::LheFileRS;
//!
//! let lhe = LheFileRS::read_lhe_from_file(&"events.lhe").unwrap();
//!
//! // x1 of the 5th event
//! let extra = lhe.events[4].extra.pdf.x1;
//! ```
//!
//! ## Supported file types
//!
//! This library comes with three specialization modules to handle extra
//! information contained in event files:
//!
//! ### plain
//!
//! The [`plain`] module allows to read `lhe` files without taking any
//! extra information into account.
//! The [`plain::LheFile`] struct contains only the information that is
//! guaranteed to be present in all `lhe` files.
//! The `extra` fields on the file, init and event objects are still
//! present, but only return dummy objects that do not contain any
//! information.
//! The `comment` and the `header` are also dummy objects.
//!
//!
//! ### string
//!
//! The [`string`] module allows to read `lhe` files and keeping all the
//! extra information in the files as unparsed strings.
//! The `comment` and the `header` are kept as strings, without the
//! start and end tags.
//! All extra information has leading and trailing whitespace removed.
//! Whitespace (including linebreaks) within the strings is conserved.
//!
//!
//! ### helac
//!
//! The [`helac`] module contains specialized structs that the extra
//! information contained in `lhe` files generated by `HELAC-NLO` is
//! parsed into.
//! The comment is kept as a string, and since `HELAC` `lhe` files do
//! not contain a header, the header is a dummy object.
//!
//!
//! ### Adding support for new file types
//!
//! To add new file types, you need to add types that implement the
//! `ReadLhe` and `WriteLhe` traits for the additional information
//! stored in the file type.
//! The type signature of the `read_from_lhe` function of the `ReadLhe`
//! trait means that you should use [`nom`] to parse your type.
//! Your implementations need to parse the opening and end tags for
//! comments (`<!--` and `-->`) and the header (`<header>` and
//! `</header>`) respectively, but must leave the tags for the init
//! section and for events alone.
//! With these implementations you can then use `LheFileGeneric` with
//! your types to read and write `lhe` files.
//!
//!
//! [`rust`]: https://www.rust-lang.org
//! [`LesHouchesEvents`]: https://arxiv.org/abs/hep-ph/0609017
//! [`MG5_aMC@NLO`]: https://launchpad.net/mg5amcnlo
//! [`HELAC_NLO`]: http://helac-phegas.web.cern.ch/helac-phegas/
//! [`nom`]: https://github.com/Geal/nom
//! [`plain`]: plain/index.html
//! [`string`]: string/index.html
//! [`helac`]: helac/index.html

extern crate lorentz_vector;
#[macro_use]
extern crate nom;

#[cfg(test)]
#[macro_use]
extern crate quickcheck;

#[cfg(test)]
#[macro_use]
extern crate serde;
#[cfg(test)]
#[cfg(test)]
extern crate serde_json;

#[macro_use]
pub mod nom_util;
pub mod generic;
pub mod helac;
pub mod plain;
pub mod string;

use lorentz_vector::LorentzVector;

use std::error;
use std::fmt;
use std::fs;
use std::io;
use std::io::Read;
use std::marker;
use std::path::Path;

#[cfg(test)]
use quickcheck::Arbitrary;
#[cfg(test)]
use quickcheck::Gen;

use nom_util::{parse_f64, parse_i64};

/// A type to use for pdg ids
///
/// See the [Particle Data Group] website for more information.
/// A list of all particle numbers can be found [here].
///
/// [Particle Data Group]: http://pdg.lbl.gov/
/// [here]: http://pdg.lbl.gov/2017/reviews/rpp2017-rev-monte-carlo-numbering.pdf
pub type PdgId = i64;

/// A trait to read (parts of) lhe files
///
/// This trait needs to be implemented for a type to be able to use it
/// in [`LheFileGeneric`] to hold extra information.
///
/// [`LheFileGeneric`]: generic/struct.LheFileGeneric.html
pub trait ReadLhe
where
    Self: marker::Sized,
{
    /// Read an lhe object from a byte string
    ///
    /// The input to this function is the remaining input in the file
    /// (or just a chunk of it) and if successful, it should return the
    /// parsed object and the input left after parsing the object.
    /// See the [`nom documentation`] for more information.
    ///
    /// [`nom documentation`]: http://rust.unhandledexpression.com/nom/
    fn read_lhe(&[u8]) -> nom::IResult<&[u8], Self>;

    /// Read an lhe object from a file
    fn read_lhe_from_file<P: AsRef<Path>>(path: &P) -> Result<Self, ReadError> {
        let mut file = fs::File::open(path)?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents)?;
        Self::read_lhe(&contents)
            .to_full_result()
            .map_err(ReadError::Nom)
    }
}

/// A trait to write (parts of) lhe files
///
/// This trait needs to be implemented for a type to be able to use it
/// in [`LheFileGeneric`] to hold extra information.
///
/// [`LheFileGeneric`]: generic/struct.LheFileGeneric.html
pub trait WriteLhe {
    /// Write the object to a writer
    fn write_lhe<W: io::Write>(&self, &mut W) -> io::Result<()>;

    /// Write the object to a file
    fn write_lhe_to_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
        let mut file = fs::File::create(path)?;
        self.write_lhe(&mut file)
    }
}

/// Errors that may occur when reading lhe objects from files
#[derive(Debug)]
pub enum ReadError {
    /// An io error occured
    Io(io::Error),
    /// A parse error occured
    Nom(nom::IError),
}

impl From<io::Error> for ReadError {
    fn from(err: io::Error) -> ReadError {
        ReadError::Io(err)
    }
}

impl fmt::Display for ReadError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            ReadError::Io(ref err) => {
                write!(f, "Failed to read the lhe file with an IO error: {}", err)
            }
            ReadError::Nom(ref err) => write!(
                f,
                "Failed to read the lhe file with a parse error: {:?}",
                err
            ),
        }
    }
}

impl error::Error for ReadError {
    fn description(&self) -> &str {
        match *self {
            ReadError::Io(..) => &"Failed to read the lhe file with an IO error",
            ReadError::Nom(..) => &"Failed to read the lhe file with a parse error",
        }
    }
    fn cause(&self) -> Option<&error::Error> {
        match *self {
            ReadError::Io(ref err) => Some(err),
            ReadError::Nom(_) => None,
        }
    }
}

/// A struct for process information
///
/// This is the per process information contained in the `init` section
/// of `lhe` files.
/// When reading a file, the `Init` struct will contain `NPRUP`
/// `ProcInfo` objects.
/// `ProcInfo` is part of the compulsory initialization information.
///
/// For more information on the fields, see the [`lhe`] paper and the
/// documentation of the [`LHA common blocks`].
/// The names in parentheses are the names of the fields in these
/// papers.
///
/// # Examples
///
/// ```rust
/// use lhef::{ProcInfo, ReadLhe};
/// use lhef::plain::LheFile;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 2
/// 2.1 3.2E-03 1.0E+00 1
/// 4.0 7.4E-03 1.0E+00 2
/// </init>
/// </LesHouchesEvents>";
/// let lhe = LheFile::read_lhe(bytes).to_full_result().unwrap();
/// assert_eq!(lhe.init.process_info.len(), 2);
/// assert_eq!(lhe.init.process_info[0].xsect, 2.1);
/// assert_eq!(lhe.init.process_info[1].xsect_err, 0.0074);
/// ```
///
/// [`lhe`]: https://arxiv.org/abs/hep-ph/0609017
/// [`LHA common blocks`]: https://arxiv.org/abs/hep-ph/0109068
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct ProcInfo {
    /// The cross section of the process (`XSECUP`)
    pub xsect: f64,
    /// The cross section error of the process (`XERRUP`)
    pub xsect_err: f64,
    /// The maximum weight of the events of the process (`XMAXUP`)
    pub maximum_weight: f64,
    /// The process id (`LPRUP`)
    pub process_id: i64,
}

impl ReadLhe for ProcInfo {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], ProcInfo> {
        do_parse!(
            input,
            xsect: ws!(parse_f64) >> xsect_err: ws!(parse_f64) >> maximum_weight: ws!(parse_f64)
                >> process_id: ws!(parse_i64) >> (ProcInfo {
                xsect,
                xsect_err,
                maximum_weight,
                process_id,
            })
        )
    }
}

impl WriteLhe for ProcInfo {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "{:e} {:e} {:e} {}",
            self.xsect, self.xsect_err, self.maximum_weight, self.process_id
        )
    }
}

#[cfg(test)]
impl Arbitrary for ProcInfo {
    fn arbitrary<G: Gen>(gen: &mut G) -> ProcInfo {
        ProcInfo {
            xsect: Arbitrary::arbitrary(gen),
            xsect_err: Arbitrary::arbitrary(gen),
            maximum_weight: Arbitrary::arbitrary(gen),
            process_id: Arbitrary::arbitrary(gen),
        }
    }
}

/// A particle in lhe format
///
/// An event will contain as many `Particle`s as there are particles in
/// the event.
/// `Particle` is part of the compulsory event information.
///
/// For more information on the fields, see the [`lhe`] paper and the
/// documentation of the [`LHA common blocks`].
/// The names in parentheses are the names of the fields in these
/// papers.
///
/// # Examples
///
/// ```rust
/// use lhef::{Particle, ReadLhe};
/// use lhef::plain::LheFile;
///
/// let bytes = b"\
/// <LesHouchesEvents version=\"1.0\">
/// <init>
/// 2212 2212 6500 6500 0 0 13100 13100 3 1
/// 2.1 3.2E-03 1.0E+00 1
/// </init>
/// <event>
/// 4 1 +1.04e-01 1.00e+03 7.54e-03 8.68e-02
/// -11 -1 0 0 0 0 +0.00e+00 +0.00e+00 +5.00e+02 5.00e+02 0.00e+00 0.00e+00 -1.00e+00
///  11 -1 0 0 0 0 -0.00e+00 -0.00e+00 -5.00e+02 5.00e+02 0.00e+00 0.00e+00  1.00e+00
/// -13  1 1 2 0 0 -1.97e+02 -4.52e+02 -7.94e+01 5.00e+02 0.00e+00 0.00e+00 -1.00e+00
///  13  1 1 2 0 0 +1.97e+02 +4.52e+02 +7.94e+01 5.00e+02 0.00e+00 0.00e+00  1.00e+00
/// </event>
/// </LesHouchesEvents>";
///
/// let lhe = LheFile::read_lhe(bytes).to_full_result().unwrap();
/// let event = &lhe.events[0];
/// assert_eq!(event.particles.len(), 4);
/// assert_eq!(event.particles[0].pdg_id, -11);
/// assert_eq!(event.particles[3].momentum.py, 452.);
/// ```
///
/// [`lhe`]: https://arxiv.org/abs/hep-ph/0609017
/// [`LHA common blocks`]: https://arxiv.org/abs/hep-ph/0109068
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct Particle {
    /// The pdg id of the particle (`IDUP`)
    pub pdg_id: PdgId,
    /// The status code of the particle (`ISTUP`)
    pub status: i64,
    /// The id of the first mother of the particle (`MOTHUP(1)`).
    /// This isn't a pdg id, but a (1 based) index into the particles vector.
    pub mother_1_id: i64,
    /// The id of the second mother of the particle (`MOTHUP(2)`).
    /// This isn't a pdg id, but a (1 based) index into the particles vector.
    pub mother_2_id: i64,
    /// The color of the particle (`ICOLUP(1)`)
    pub color_1: i64,
    /// The color of the particle (`ICOLUP(2)`)
    pub color_2: i64,
    /// The four momentum of the particle (`PUP` 1 - 4)
    pub momentum: LorentzVector,
    /// The mass of the particle (`PUP(5)`)
    pub mass: f64,
    /// The proper lifetime of the particle (`VTIMUP`)
    pub proper_lifetime: f64,
    /// The spin of the particle (`SPINUP`)
    pub spin: f64,
}

impl ReadLhe for Particle {
    fn read_lhe(input: &[u8]) -> nom::IResult<&[u8], Particle> {
        do_parse!(
            input,
            pdg_id: ws!(parse_i64) >> status: ws!(parse_i64) >> mother_1_id: ws!(parse_i64)
                >> mother_2_id: ws!(parse_i64) >> color_1: ws!(parse_i64)
                >> color_2: ws!(parse_i64) >> px: ws!(parse_f64) >> py: ws!(parse_f64)
                >> pz: ws!(parse_f64) >> e: ws!(parse_f64) >> mass: ws!(parse_f64)
                >> proper_lifetime: ws!(parse_f64) >> spin: ws!(parse_f64)
                >> (Particle {
                    pdg_id,
                    status,
                    mother_1_id,
                    mother_2_id,
                    color_1,
                    color_2,
                    momentum: LorentzVector { e, px, py, pz },
                    mass,
                    proper_lifetime,
                    spin,
                })
        )
    }
}

impl WriteLhe for Particle {
    fn write_lhe<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writeln!(
            writer,
            "{} {} {} {} {} {} {:e} {:e} {:e} {:e} {:e} {:e} {:e}",
            self.pdg_id,
            self.status,
            self.mother_1_id,
            self.mother_2_id,
            self.color_1,
            self.color_2,
            self.momentum.px,
            self.momentum.py,
            self.momentum.pz,
            self.momentum.e,
            self.mass,
            self.proper_lifetime,
            self.spin
        )
    }
}

#[cfg(test)]
impl Arbitrary for Particle {
    fn arbitrary<G: Gen>(gen: &mut G) -> Particle {
        let momentum = LorentzVector {
            e: Arbitrary::arbitrary(gen),
            px: Arbitrary::arbitrary(gen),
            py: Arbitrary::arbitrary(gen),
            pz: Arbitrary::arbitrary(gen),
        };
        Particle {
            pdg_id: Arbitrary::arbitrary(gen),
            status: Arbitrary::arbitrary(gen),
            mother_1_id: Arbitrary::arbitrary(gen),
            mother_2_id: Arbitrary::arbitrary(gen),
            color_1: Arbitrary::arbitrary(gen),
            color_2: Arbitrary::arbitrary(gen),
            momentum,
            mass: Arbitrary::arbitrary(gen),
            proper_lifetime: Arbitrary::arbitrary(gen),
            spin: Arbitrary::arbitrary(gen),
        }
    }
}

#[cfg(test)]
mod tests {
    use lorentz_vector::LorentzVector;
    use super::{ReadLhe, WriteLhe};
    use super::{Particle, ProcInfo};

    #[test]
    fn read_procinfo() {
        let bytes = b"1. 2. 3. 4\n";
        let expected = ProcInfo {
            xsect: 1.,
            xsect_err: 2.,
            maximum_weight: 3.,
            process_id: 4,
        };
        let result = ProcInfo::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn read_particle() {
        let bytes = b"1 2 3 4 5 6 7. 8. 9. 10. 11. 12. 13.\n";
        let expected = Particle {
            pdg_id: 1,
            status: 2,
            mother_1_id: 3,
            mother_2_id: 4,
            color_1: 5,
            color_2: 6,
            momentum: LorentzVector {
                px: 7.,
                py: 8.,
                pz: 9.,
                e: 10.,
            },
            mass: 11.,
            proper_lifetime: 12.,
            spin: 13.,
        };
        let result = Particle::read_lhe(bytes).to_full_result().unwrap();
        assert_eq!(result, expected);
    }

    quickcheck! {
        fn proc_info_roundtrip_qc(p: ProcInfo) -> bool {
            let mut bytes = Vec::new();
            p.write_lhe(&mut bytes).unwrap();
            let round = match ProcInfo::read_lhe(&bytes).to_full_result() {
                Ok(r) => r,
                Err(err) => panic!("Failed to read roundtrip: {:?}", err),
            };
            p == round
        }
    }

    quickcheck! {
        fn particle_roundtrip_qc(m: Particle) -> bool {
            let mut bytes = Vec::new();
            m.write_lhe(&mut bytes).unwrap();
            let round = match Particle::read_lhe(&bytes).to_full_result() {
                Ok(r) => r,
                Err(err) => panic!("Failed to read roundtrip: {:?}", err),
            };
            m == round
        }
    }
}
